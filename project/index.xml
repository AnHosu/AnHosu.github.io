<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Projects | anders e</title>
    <link>/project/</link>
      <atom:link href="/project/index.xml" rel="self" type="application/rss+xml" />
    <description>Projects</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>Â© 2023 Anders E. Nielsen</copyright><lastBuildDate>Wed, 15 Mar 2023 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/media/icon_hu0b500a15011e1e483635372eebf6e1df_24681_512x512_fill_lanczos_center_3.png</url>
      <title>Projects</title>
      <link>/project/</link>
    </image>
    
    <item>
      <title>Bayesian Biochemistry</title>
      <link>/project/bayesian-biochemistry/</link>
      <pubDate>Wed, 15 Mar 2023 00:00:00 +0000</pubDate>
      <guid>/project/bayesian-biochemistry/</guid>
      <description>&lt;p&gt;I am on a quest to improve the model fitting I do on biochemical assays. For some time, I have had this feeling that I should be able to extract more information from the data gathered in biochemical assays, in particular assays with a high throughput. I have been using classical machine learning techniques and generic fitting and optimisation functions to interpret data from such assays. While this approach works, it also neglects much of the available domain expertise. Many of the underlying biochemical mechanisms are known and I would like my models to take that into account so I get results that are more directly interpretable in the context of the hypothesis that required the assay in the first place. In other words, I want a bespoke model.&lt;/p&gt;
&lt;p&gt;Through three incremental iterations, I have built a bespoke Bayesian Model for biochemical assays that seek to quantify a dose-response. These are common assays in drug development and provide the foundation for screening as well as optimisation experiments.&lt;/p&gt;
&lt;h2 id=&#34;posts-in-the-series&#34;&gt;Posts in the Series&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;../post/bespoke-biochem-one/&#34;&gt;Bespoke Bayesian Model for Biochemical Assays&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In this, I build a Bayesian model for a single dose-response curve, representing a single experiment.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;../post/bespoke-biochem-two/&#34;&gt;Bespoke Bayesian Model for High Throughput Biochemical Assays&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In this, I build a Bayesian model for a screening experiment with multiple variations of a compound.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;../post/bespoke-biochem-three/&#34;&gt;Bespoke Bayesian Model for High Throughput Biochemical Assays with Batch Effects&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Post coming soon. In this, I add upon the screening experiment, by showing how to account for batch effects and include covariates in the Bayesian model.&lt;/p&gt;
&lt;h2 id=&#34;license&#34;&gt;License&lt;/h2&gt;
&lt;p&gt;The content of this project itself is licensed under the &lt;a href=&#34;https://creativecommons.org/licenses/by-sa/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Creative Commons Attribution-ShareAlike 4.0 International license&lt;/a&gt;, and the underlying code is licensed under the &lt;a href=&#34;LICENSE&#34;&gt;GNU General Public License v3.0 license&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bayesian Optimisation Tools and Tutorials</title>
      <link>/project/bayesian-optimisation/</link>
      <pubDate>Wed, 15 Mar 2023 00:00:00 +0000</pubDate>
      <guid>/project/bayesian-optimisation/</guid>
      <description>&lt;h1 id=&#34;bayesian-optimisation-tools-and-tutorials&#34;&gt;Bayesian Optimisation Tools and Tutorials&lt;/h1&gt;
&lt;p&gt;This is the repo for my Bayesian optimisation project. For rendered versions of this page and individual sections, visit &lt;a href=&#34;https://anhosu.com/project/bayesian-optimisation/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;my website&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;When trying to optimise valuable industrial processes, like manufacturing, drug development, or supply chains, I often encounter the same challenge. There is little relevant historical data available and it is extremely expensive to conduct experiments on the process.&lt;/p&gt;
&lt;p&gt;My go-to tool in these cases is Bayesian optimisation.&lt;/p&gt;
&lt;p&gt;Bayesian optimisation is a powerful tool to perform optimisation of opaque, complex processes. Bayesian optimisation uses a probabilistic model as a surrogate for the opaque process. This model is updated with sequential experiments that the model itself helps design. With relatively few experiments, Bayesian optimisation can find good maxima or minima.&lt;/p&gt;
&lt;p&gt;The probabilistic model allows us to incorporate our prior knowledge about the process at hand and gives us a head start in the optimisation. However, for the same reason, Bayesian optimisation is sensitive to initial assumptions, and there are a lot of moving parts.&lt;/p&gt;
&lt;p&gt;With this project, I aim to introduce and discuss the components of Bayesian optimisation. However, I will focus less on the mathematical intricacies and put more emphasis on the assumptions and implementation of each component.&lt;/p&gt;
&lt;h2 id=&#34;posts-on-bayesian-optimisation&#34;&gt;Posts on Bayesian Optimisation&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://anhosu.com/post/bayesian-opt-r&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bayesian Optimisation from Scratch in R&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This post introduces and demonstrates all the core components of Bayesian optimisation and implements them from scratch in R. This is a great place to start.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://anhosu.com/post/kernels-r/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kernel Functions&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This post contains a comprehensive list and discussion of kernels to use in the Gaussian processes surrogate model, when doing Bayesian optimisation. Accompanying the discussion, are implementations in R. The kernel is the main way to incorporate prior information into a surrogate model, making it an important choice, when setting up Bayesian optimisation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://anhosu.com/post/acquisition-functions-r/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Acquisition Functions&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This post discusses acquisition functions, which are used to recommend the next point to sample in the experiment sequence. Acquisition functions are the main means of balancing exploration and exploitation during optimisation. The post lists a number of acquisition functions and implements them in R.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://anhosu.com/post/surrogate-alternatives-r/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Alternative Surrogate Models&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Gaussian processes are almost the default choice for surrogate models in Bayesian optimisation and they do perform well for many diverse tasks. However, a Gaussian process might not always be the right choice. This post discusses and implements four alternatives to Gaussian processes as surrogate models for Bayesian optimisation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://anhosu.com/post/initial-designs-r/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Initial Designs&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The first step in Bayesian optimisation is the initial experiment design, which provides the base data for a surrogate model. This post discusses the significance of initial experiment designs for Bayesian optimisation, and explores a few examples, including Latin Hypercube Sampling (LHS), while highlighting their advantages and limitations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testing Bayesian Optimisation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This post is coming soon.&lt;/p&gt;
&lt;h2 id=&#34;license&#34;&gt;License&lt;/h2&gt;
&lt;p&gt;The content of this project itself is licensed under the &lt;a href=&#34;https://creativecommons.org/licenses/by-sa/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Creative Commons Attribution-ShareAlike 4.0 International license&lt;/a&gt;, and the underlying code is licensed under the &lt;a href=&#34;https://github.com/AnHosu/bayes-opt/blob/2b81cc2c765cf5aa76e62a2da387c3b4ca1695a9/LICENSE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GNU General Public License v3.0 license&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Industrial IoT with AWS and Python</title>
      <link>/project/iot-poc/</link>
      <pubDate>Tue, 16 Jun 2020 00:00:00 +0000</pubDate>
      <guid>/project/iot-poc/</guid>
      <description>&lt;p&gt;This is an introduction to and a series of demonstrations of concepts in Industrial Internet of Things (iIoT). It is a port of my &lt;a href=&#34;https://github.com/AnHosu/iot_poc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub repository&lt;/a&gt;, where all code and materials are available.&lt;br&gt;
On one hand, it is a simple introduction to how we might go about getting our sensor data from sensors to the cloud. On the other hand, we will dive into advanced IoT concepts. So if you are looking for demonstrations of concepts like edge inference, device fleet management, MQTT, and shadow records you have come to the right place.&lt;br&gt;&lt;br&gt;
There are many ways to do IoT and there is an ocean of offerings out there. This introduction focuses on AWS IoT services like IoT Core and Greengrass and uses the AWS IoT SDK for Python. The concepts are transferrable to other services, but we will write code specifically for AWS IoT and we will do so mostly in Python.&lt;br&gt;&lt;br&gt;
AWS offers multiple ways to ingest and store data but, for industrial scale sensor data, it especially makes sense to look at the AWS IoT and streaming offerings. However, even here there are different ways to go about doing the same thing and the nuances can get confusing. This tutorial consists of a general introduction and five seperate demonstrations designed to exemplify increasingly complex IoT functionality. In each demonstration, We will work from scratch to the full setup, making it a full proof of concept for an AWS IoT architecture. I recommend starting at case 1 and working your way through each case before proceeding to the next. A full disclaimer before you get started though; the tutorial does reflect some subjective opinions and I am by no means an expert on the subject, but the tutorial arises from my work with IoT in a manufacturing setting.&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;contents&#34;&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#the-hardware-setup&#34;&gt;Hardware Setup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#case-setups&#34;&gt;Cases&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-publish-industrial-data-with-aws-iot&#34;&gt;Simple Publishing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-publish-and-subscribe&#34;&gt;Publish and Subscribe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-utilise-thing-shadows&#34;&gt;Utilise Thing Shadows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-build-an-edge-with-greengrass&#34;&gt;Build an Edge with Greengrass&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-advanced-greengrass-features&#34;&gt;Advanced Features and ML in Greengrass&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#iot-with-aws-iot&#34;&gt;Introduction to AWS IoT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;the-hardware-setup&#34;&gt;The Hardware Setup&lt;/h1&gt;
&lt;p&gt;It would not be IoT without at least one device. The demonstrations focus on the software layer but use actual hardware, not simulations, to prove concepts. I have been using a Raspberry Pi 3 Model B+ along with a Bosch BME680 sensor on a &lt;a href=&#34;https://shop.pimoroni.com/products/bme680-breakout&#34; title=&#34;Pimoroni BME680 breakout&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;breakout&lt;/a&gt;. Any sensor would do, but I like this one and this particular breakout beacause it has a nice &lt;a href=&#34;https://github.com/pimoroni/bme680-python&#34; title=&#34;Pimoroni BME680 library&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;library&lt;/a&gt; which allows us to reduce the amount of code we need to query our sensor to a minimum. Furthermore, this particular sensor has four different components, allowing us to measure temperature, atmospheric pressure, relative humidity, and, with a bit of additional work, air quality. I will not elaborate too much on this particular sensor equipment for this demonstration and I will try to be clear about when you can replace my example code with code querying your particular sensor.&lt;br&gt;&lt;br&gt;
In IoT terms the sensor is the &amp;lsquo;Thing&amp;rsquo; or &amp;lsquo;Device&amp;rsquo;, and our Raspberry Pi is the &amp;lsquo;Edge&amp;rsquo; or &amp;lsquo;Gateway Device&amp;rsquo;. Names are not too important and, in real life, you would use different hardware for different situations.&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;
	&lt;img width=500 src=&#34;images/hardware_setup.jpg&#34; alt=&#34;iot setup&#34;&gt;
	&lt;br&gt;
    Raspberry Pi 3 Model B+ with the BME680 sensor. The sensor is intentionally placed quite close to the CPU, which will interfere with the temperature readings. In demonstration 4, we will deploy calculations from AWS onto the Pi to correct for this, as an example of edge calculations.
    &lt;br&gt;
    &lt;br&gt;
&lt;/div&gt;
&lt;p&gt;Hardware-wise everything will be the same throughout each demonstration; BME680 connected to the Pi which is connected to the internet. If you are using the same breakout, take a look at &lt;a href=&#34;https://learn.pimoroni.com/tutorial/sandyj/getting-started-with-bme680-breakout&#34; title=&#34;BME680 tutorial&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this tutorial&lt;/a&gt; to set it up.&lt;/p&gt;
&lt;h1 id=&#34;demonstrations&#34;&gt;Demonstrations&lt;/h1&gt;
&lt;p&gt;The five demonstrations are the main attraction of this tutorial, and if you are looking for examples and code snippets, then go ahead and dive right in. If you prefer a bit of theoretical background before you get started, then jump to the next section before starting the cases.&lt;/p&gt;
&lt;h2 id=&#34;1-publish-industrial-data-with-aws-iot&#34;&gt;1) Publish Industrial Data with AWS IoT&lt;/h2&gt;
&lt;p&gt;The simplest way to do IoT with AWS. We will register our sensor as a thing in AWS IoT Core and will be using the AWS IoT Python SDK to publish sensor readings to a topic. We go through concepts such as things, topics, MQTT, and more.&lt;br&gt;
In this case, the Raspberry Pi is simply simulating a microcontroller that will query the sensor and publish the result.&lt;br&gt;&lt;br&gt;
&lt;a href=&#34;../post/iot-poc-publishing/&#34; title=&#34;simple publishing case&#34;&gt;Get started here&lt;/a&gt;.
Here is the full &lt;a href=&#34;https://github.com/AnHosu/iot_poc/blob/master/example_scripts/simple_publishing.py&#34; title=&#34;simple publishing example&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;example script&lt;/a&gt;.&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;
	&lt;img width=&#34;500&#34; src=&#34;images/publishing_architecture.png&#34; alt=&#34;IoT overview&#34;&gt;
  &lt;br&gt;
  Schematic of the architecture we are building in the demonstration of publishing.
&lt;/div&gt;
&lt;h2 id=&#34;2-publish-and-subscribe&#34;&gt;2) Publish and Subscribe&lt;/h2&gt;
&lt;p&gt;In this case, we build upon the previous case and will construct a setup where our device will not just send data but also respond to messages sent to it.&lt;br&gt;
The Raspberry Pi is still just simulating a microcontroller, but we start to see how having compute at the edge is useful and can be managed with AWS IoT.&lt;br&gt;&lt;br&gt;
&lt;a href=&#34;../post/iot-poc-pubsub&#34; title=&#34;simple pub/sub case&#34;&gt;Get started here&lt;/a&gt;. Here is the full &lt;a href=&#34;https://github.com/AnHosu/iot_poc/blob/master/example_scripts/simple_pubsub.py&#34; title=&#34;simple pubsub example&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;example script&lt;/a&gt;.&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;
	&lt;img width=&#34;500&#34; src=&#34;images/pubsub_architecture.png&#34; alt=&#34;pubsub overview&#34;&gt;
  &lt;br&gt;
  Schematic of the architecture we are building in the demonstration of publishing and subscribing.
&lt;/div&gt;
&lt;h2 id=&#34;3-utilise-thing-shadows&#34;&gt;3) Utilise Thing Shadows&lt;/h2&gt;
&lt;p&gt;Using the Thing Shadow feature of AWS IoT, we will create a twin/shadow of our device in the cloud and update it whenever a new reading is available. We could use this cool feature to build a digital twin of our process.&lt;br&gt;
The Raspberry Pi is still simulating a microcontroller that will query the sensor, but instead of just publishing the result, it will update the Shadow document of the thing, our sensor.&lt;br&gt;&lt;br&gt;
&lt;a href=&#34;../post/iot-poc-shadow/&#34; title=&#34;Shadow case&#34;&gt;Get started here&lt;/a&gt;. Here is the full &lt;a href=&#34;https://github.com/AnHosu/iot_poc/blob/master/example_scripts/shadow.py&#34; title=&#34;shadow example&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;example script&lt;/a&gt;.&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;
	&lt;img width=500 src=&#34;images/shadow_architecture.png&#34; alt=&#34;iot setup&#34;&gt;
	&lt;br&gt;
  Schematic of the architecture we are building in the demonstration of Shadow functionality.
&lt;/div&gt;
&lt;h2 id=&#34;4-build-an-edge-with-greengrass&#34;&gt;4) Build an Edge with Greengrass&lt;/h2&gt;
&lt;p&gt;Now our Pi will act the part of gateway device. The gateway device effectively represents an edge that is manageable from the cloud and where data transformations or calculations can happen. This could be signal processing, edge analytics, or even machine learning models. Greengrass is the AWS software offering for gateway devices. In this demonstration, we will set up Greengrass on the Pi, connect a thing, our sensor, to Greengrass, and deploy a calculation from the cloud to the edge using a Lambda function.&lt;br&gt;&lt;br&gt;
&lt;a href=&#34;../post/iot-poc-greengrass&#34; title=&#34;Greengrass case&#34;&gt;Get started here&lt;/a&gt;. Here is the full &lt;a href=&#34;https://github.com/AnHosu/iot_poc/blob/master/example_scripts/greengrass_thing.py&#34; title=&#34;Example of Thing for Greengrass&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;example script for a local device&lt;/a&gt; and the &lt;a href=&#34;https://github.com/AnHosu/iot_poc/blob/master/example_scripts/greengrass_sys_lambda.py&#34; title=&#34;Lambda example&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Lambda function&lt;/a&gt; we will deploy into Greengrass Core.&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;
	&lt;img width=500 src=&#34;images/greengrass_group_architecture.png&#34; alt=&#34;iot setup&#34;&gt;
    &lt;br&gt;
    This is the architecture we are building in the demonstration of Greengrass functionality.
	&lt;br&gt;
&lt;/div&gt;
&lt;h2 id=&#34;5-advanced-greengrass-features&#34;&gt;5) Advanced Greengrass Features&lt;/h2&gt;
&lt;p&gt;In this final demonstration, we will combine everything from the previous demonstrations to deploy a machine learning model from the cloud into Greengrass and do inference at the edge. This requires us to explore additional advanced features and configurations of Greengrass, but shows how, with a few means and a bit of engineering, we can achieve quite complex functionality.&lt;br&gt;&lt;br&gt;
&lt;a href=&#34;../post/iot-poc-greengrass-ml&#34; title=&#34;Advanced Greengrass case&#34;&gt;Get started here&lt;/a&gt;. This demonstration uses the same &lt;a href=&#34;https://github.com/AnHosu/iot_poc/blob/master/example_scripts/greengrass_thing.py&#34; title=&#34;Example of Thing for Greengrass&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;example script for a local device&lt;/a&gt; as the previous but has two new examples of Lambda functions, &lt;a href=&#34;https://github.com/AnHosu/iot_poc/blob/master/example_scripts/ml_inference_lambda.py&#34; title=&#34;ML inference Lambda&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;including one&lt;/a&gt; doing machine learning inference.&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;
	&lt;img width=500 src=&#34;images/greengrass_ml_architecture.png&#34; alt=&#34;Greengrass ML Demo Architechture&#34;&gt;
	&lt;br&gt;
    This is the architechture of the application we will build in the demonstration of advanced Greengrass Features.
&lt;/div&gt;
&lt;h1 id=&#34;iot-with-aws-iot&#34;&gt;IoT with AWS IoT&lt;/h1&gt;
&lt;p&gt;This section has a bit of theoretical context for the demonstrations. We will try to understand some core concepts of internet of things in the context of an industrial setting and AWS IoT.&lt;/p&gt;
&lt;h2 id=&#34;things&#34;&gt;Things&lt;/h2&gt;
&lt;p&gt;Let us start with the Things in an internet of things. In an industrial setting, a thing is often anything that has a measurable state, is being actively measured, and is connected to a network. A simple example might be temperature at the factory floor. This is obviously a critical variable in many manufacturing processes and one can often find old school thermometers installed here and there. These are not things, however, until they are connected to a network either directly or indirectly through a gateway device. Other examples could be the airflow through a specific nozzle or the injection pressure for the plastic in an injection moulding process. The airflow could be measured using a flowmeter and the injection pressure with a pressure sensor. These could then be connected to a small computer that in turn connects to the internet.&lt;br&gt;&lt;br&gt;
Given this vague definition of things, an obvious question arises for those who have been in a manufacturing context for a while. Manufacturing processes are usually associated with process control loops. These include connecting key process parameters to a process logic controller (PLC) that in turn controls actuators to regulate the process. An example would be the flow of water through a pipe, measured by a flow sensor and regulated by the opening or closing of a valve. The question is: are these control loops also IoT?&lt;br&gt;The answer is that they could be. The process parameters and the state of the valve are all potential things that when connected to a network could become things in an internet of things. The key difference between IoT and a control loop would be all the other things and applications that might be on the network. The PLC is there to do process control, not neccessarily to send or store data, and connecting it to new networks could be a major risk for the manufacturing process, but also potentially unlocks the data for new valuable applications. In IoT, we use dedicated devices to buffer and send data to storage in the cloud or somewhere else.&lt;br&gt;&lt;br&gt;
One network that an IoT could take advantage of is a cloud. Cloud service providers like AWS and Azure have IoT-specific offerings that can help build new IoTs. AWS is our cloud of choice for this tutorial. In AWS IoT Core, we can &lt;a href=&#34;https://docs.aws.amazon.com/iot/latest/developerguide/create-aws-thing.html&#34; title=&#34;how to register a thing in AWS IoT Core&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;register&lt;/a&gt; and manage our things. A thing is the highest level of granularity, and it makes sense to register each parameter we measure as a seperate thing. We can then aggregate and manage hierarchies of things using &lt;a href=&#34;https://docs.aws.amazon.com/iot/latest/developerguide/iot-thing-management.html&#34; title=&#34;about managing hierarchies of things&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;groups and types&lt;/a&gt;.&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;
	&lt;img width=500 src=&#34;images/iot_overview.png&#34; alt=&#34;iot setup&#34;&gt;
	&lt;br&gt;
&lt;/div&gt;
&lt;h2 id=&#34;the-edge-and-gateway-devices&#34;&gt;The Edge and Gateway Devices&lt;/h2&gt;
&lt;p&gt;We stumbled up the term gateway devices a few times. A gateway device is basically just a computer. It could be as small as a microcontroller and as large as a distributed compute system. In this tutorial we will use a Raspberry Pi to play the part of gateway device. In an industrial setting the gateway devices are there to do the things that a PLC should not do, like connecting to the internet, doing heavy calculations, and buffering data. It might be obvious at this point, but the gateway device is essentially what is referred to as the &amp;lsquo;edge&amp;rsquo;. Running machine learning at the edge essentially means having a machine learning algorithm do inference using the compute in our gateway device. A gateway device can be used for a bunch of other things though, such as signal processesing, data aggregation, or data transformation. Imagine for instance that our sensor reports the factory floor temperature in degrees Celcius. Maybe we want to convert that into Kelvins before sending and storing it in the cloud. Of course we could store the measurement in Celcius and then do the transformation later or directly in our application, but that would be more expensive (cloud compute is expensive, cloud storage is cheap) and less elegant. We run our computations at the edge whenever it makes sense and save money.&lt;br&gt;&lt;br&gt;
The edge device is where we will run the client that connects to AWS IoT, sends data, and maybe receives instructions. To do so we will use the AWS IoT Python SDK. AWS also provides software for managing and running our applications on gateway devices. These are called Greengrass and SiteWise (which is just additional software on top of Greengrass). Greengrass allows us to do cool things such as running Lambda functions and deploy machine learning models from the cloud to the edge. Greengrass and its functionality is covered in demonstrations 4 and 5.&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;shadows&#34;&gt;Shadows&lt;/h2&gt;
&lt;p&gt;We are doing IoT for a reason. Maybe we are building a dashboard for the operators of our manufacturing line, maybe we are developing a predictive maintenance model that uses measured parameters from the line to predict the remaining lifespan of a critical component. Whatever our application, we will need fresh data from our things. Unless we have gone all in on a massive synchronisation effort, our data points will not arrive at exactly matching timestamps, however. Factory floor humidity might be reported every 5 minutes while frequency and amplitude of a vibrating element might be reported every 15 seconds. Maybe the gateway device handling data from our flow sensors has been updating its software such that no values have been reported for the past 12 minutes. What does our application do when the refresh rate might be every 30 seconds? If all values are stored in a database, the application could just grab the latest values, but that might not be possible or introduce unwanted latency. There is another way, however.&lt;br&gt;&lt;br&gt;
A Shadow record is a record of the latest process parameters, such that the currently most reliable view of reality is always available for applications. The notion is similar to a database, the key difference being that this record only ever keeps the latest entry. With such a record we can design our application to do what it needs to do and even dynamically correct for old data without ever worrying about not having available data or waiting for data to appear, thus effectively decoupling the IoT and our application.&lt;br&gt;&lt;br&gt;
Shadow records are a part of the AWS IoT offering. Each thing registered in AWS IoT automatically has a shadow, which is a json document containing the latest record for that thing, assuming we have set up our IoT to update it. In demonstration 3, we will explore how to interact with shadows in the cloud. Using Greengrass, we can also keep a shadow on the edge and even enable shadow synchronisation between the edge and the cloud. In this way our applications running at the edge can access shadow records with low latency, while cloud based applications have a copy available to them as well. We will explore the use of local shadows with Greengrass for a machine learning application in demonstration 5.&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;
	&lt;img width=&#34;500&#34; src=&#34;images/shadow_flow.png&#34; alt=&#34;iot setup&#34;&gt;
	&lt;br&gt;
&lt;/div&gt;
&lt;h2 id=&#34;sdk&#34;&gt;SDK&lt;/h2&gt;
&lt;p&gt;We will be using the Python SDK to configure the client that communicates with AWS. This means that our gateway device has to be able to run Python. This is no problem on a Raspberry Pi, but would not work for a microcontroller and probably would not be ideal for a web application. AWS IoT offers SDKs for a bunch of &lt;a href=&#34;https://docs.aws.amazon.com/iot/latest/developerguide/iot-sdks.html&#34; title=&#34;AWS IoT SDKs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;other languages&lt;/a&gt;, however.&lt;br&gt;
This tutorial uses the &lt;a href=&#34;https://github.com/aws/aws-iot-device-sdk-python&#34; title=&#34;AWS IoT Python SDK V1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;first version&lt;/a&gt; of the Python SDK. A &lt;a href=&#34;https://github.com/aws/aws-iot-device-sdk-python-v2&#34; title=&#34;AWS IoT Python SDK V2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;version two&lt;/a&gt; that uses a very different syntax was released, but will not be covered here.&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;the-mqtt-protocol&#34;&gt;The MQTT Protocol&lt;/h2&gt;
&lt;p&gt;Communication with AWS is facilitated by the MQTT protocol. This is a protocol commonly used in manufacturing systems, and is documented &lt;a href=&#34;http://mqtt.org/documentation&#34; title=&#34;MQTT documentation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;online&lt;/a&gt;. The &lt;a href=&#34;https://docs.aws.amazon.com/iot/latest/developerguide/mqtt.html&#34; title=&#34;AWS MQTT Documentation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AWS flavour&lt;/a&gt; of MQTT is a slightly simpler implementation of the protocol. Communicating using HTTPS is also possible but is not covered in this tutorial.&lt;br&gt;&lt;br&gt;
To get started using the MQTT protocol with AWS IoT, we only need to know a few concepts: message, topic, quality of service (QoS), publishing, and subsribing. These concepts are summarised right here, but we will discuss them in detail when they show up in the demonstrations.&lt;/p&gt;
&lt;h3 id=&#34;messages&#34;&gt;Messages&lt;/h3&gt;
&lt;p&gt;At the core of MQTT is the message, The message contains the actual data along with any metadata. It is structured as a json and we can put whatever we want in there, but we will want the reading from our thing, a timestamp for the time of sampling, and maybe an idication whether the reading was succesful or not.&lt;/p&gt;
&lt;h3 id=&#34;topics&#34;&gt;Topics&lt;/h3&gt;
&lt;p&gt;Messages in AWS are distributed and filtered using topics. Topics are a kind of tag that we can use to identify the source of the message and distribute it accordingly. It is just a single string, generally in the format&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main_tag/secondary_tag/tertiary_tag/etc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For instance, if we had several factories each with several manufacturing lines with several stations each eqipped with sensors, we might do something like&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;factoryA/line22/drying/temperature
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then have another sensor on the same line publish to&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;factoryA/line22/milling/torque
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That way we can direct these messages to the store or dashboard for the same line but seperate Lambda functions, if that is needed for our application.&lt;br&gt;
The topic system is quite flexible and we will have to rely on our own rigid naming conventions if we want to effectivly utilise topics in an application with many things. Some specific topics are reserved for specific purposes such as interacting with shadows. We will dive deeper into the use of topics and reserved topics in the demonstrations.&lt;/p&gt;
&lt;h3 id=&#34;publishing-and-subscribing&#34;&gt;Publishing and Subscribing&lt;/h3&gt;
&lt;p&gt;Messages are transmitted using the publish subscribe model. A message always has a single publisher. The publisher client is the origin of the message and will publish that message to a given topic. A topic can have several publishes, meaning that several clients can publish messages to the same topic. Messages reach their destination through subscribers. Subscribers are clients that listen to a topic to get whatever messages are published there. A topic can also have multiple subscribers.&lt;/p&gt;
&lt;h3 id=&#34;serverbroker&#34;&gt;Server/Broker&lt;/h3&gt;
&lt;p&gt;The MQTT server is responsible for orchestrating the MQTT communication. It is the server that will authenticate MQTT clients and will route messages from publishers to subscribers using topic filters. AWS IoT Cores is essentially an infinitely scalable MQTT server. Greengrass is also an MQTT server that runs locally on a gateway device.&lt;/p&gt;
&lt;h3 id=&#34;client&#34;&gt;Client&lt;/h3&gt;
&lt;p&gt;The MQTT client is used to create an MQTT publisher or a subscriber. The core functionality of the AWS IoT SDKs is to abstract away the intricacies of setting up and authenticating an MQTT client.&lt;/p&gt;
&lt;h3 id=&#34;quality-of-service&#34;&gt;Quality of Service&lt;/h3&gt;
&lt;p&gt;Quality of Service, abbreviated QoS, is a flag specifying what happens when messages get lost in the network. The AWS flavour of MQTT accepts two QoS flags. The flag 0 means that the message is delivered to subsrcibers &amp;lsquo;at most once&amp;rsquo;. The flag 1 means that the message is delivered to subsribers &amp;lsquo;at least once&amp;rsquo;. So for &lt;code&gt;QoS = 0&lt;/code&gt; the publisher will send the message once and then forget about it. If it does not get delivered, it is lost. For &lt;code&gt;QoS = 1&lt;/code&gt;, however, the message is sent, and the publisher then waits for a reply from the subscriber before forgetting the message, and resends if neccessary. This ensures that the subscriber gets the message at least once.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
