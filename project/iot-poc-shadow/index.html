<!DOCTYPE html><html lang="en-us" >

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  
  
    <meta name="generator" content="Wowchemy 5.1.0 for Hugo" />
  

  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="Anders E. Nielsen" />

  
  
  
    
  
  <meta name="description" content="In this tutorial, we discuss the usefulness of thing shadows in industrial IoT, by demonstrating how it keeps the pub/sub network alive even if the thing intermittently goes offline." />

  
  <link rel="alternate" hreflang="en-us" href="../../project/iot-poc-shadow/" />

  







  




  
  
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  

  
  
  
    <meta name="theme-color" content="#023e8a" />
  

  
  
    
    <script src="../../js/mathjax-config.js"></script>
  

  
  
  
  
    
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha256-FMvZuGapsJLjouA6k7Eo2lusoAX9i0ShlWFG6qt7SLc=" crossorigin="anonymous">

    
    

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/github.min.css" crossorigin="anonymous" title="hl-light" media="print" onload="this.media='all'">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" media="print" onload="this.media='all'" disabled>
        
      
    

    
    
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.min.css" integrity="sha512-1xoFisiGdy9nvho8EgXuXvnpR5GAMSjFwp40gSRE3NwdUdIMIKuPa7bqoUhLD0O/5tPNhteAsE5XyyMi5reQVA==" crossorigin="anonymous" media="print" onload="this.media='all'">
    

    

    
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" integrity="" crossorigin="anonymous" async></script>
      
    
      
      

      
      

      
    
      
      

      
      

      
    
  

  
  
  
    
      
      
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather%7CRoboto+Mono&display=swap">
      
    
  

  
  
  
  
  
  <link rel="stylesheet" href="../../css/wowchemy.f7eaf83122b08ab266aaa8a2d08cb1e8.css" />

  



  

  

  




  
  
  

  

  
    <link rel="manifest" href="../../index.webmanifest" />
  

  <link rel="icon" type="image/png" href="../../media/icon_hu0b500a15011e1e483635372eebf6e1df_24681_32x32_fill_lanczos_center_3.png" />
  <link rel="apple-touch-icon" type="image/png" href="../../media/icon_hu0b500a15011e1e483635372eebf6e1df_24681_180x180_fill_lanczos_center_3.png" />

  <link rel="canonical" href="../../project/iot-poc-shadow/" />

  
  
  
  
  
  
  
  
    
  
  
  <meta property="twitter:card" content="summary_large_image" />
  
  <meta property="og:site_name" content="anders e" />
  <meta property="og:url" content="/project/iot-poc-shadow/" />
  <meta property="og:title" content="Thing Shadows with AWS IoT | anders e" />
  <meta property="og:description" content="In this tutorial, we discuss the usefulness of thing shadows in industrial IoT, by demonstrating how it keeps the pub/sub network alive even if the thing intermittently goes offline." /><meta property="og:image" content="/project/iot-poc-shadow/featured.png" />
    <meta property="twitter:image" content="/project/iot-poc-shadow/featured.png" /><meta property="og:locale" content="en-us" />
  
    
      <meta
        property="article:published_time"
        content="2020-06-16T00:00:00&#43;00:00"
      />
    
    <meta property="article:modified_time" content="2020-06-16T00:00:00&#43;00:00">
  

  


    









<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Article",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/project/iot-poc-shadow/"
  },
  "headline": "Thing Shadows with AWS IoT",
  
  "image": [
    "/project/iot-poc-shadow/featured.png"
  ],
  
  "datePublished": "2020-06-16T00:00:00Z",
  "dateModified": "2020-06-16T00:00:00Z",
  
  "author": {
    "@type": "Person",
    "name": "Anders E. Nielsen"
  },
  
  "publisher": {
    "@type": "Organization",
    "name": "anders e",
    "logo": {
      "@type": "ImageObject",
      "url": "/media/icon_hu0b500a15011e1e483635372eebf6e1df_24681_192x192_fill_lanczos_center_3.png"
    }
  },
  "description": "In this tutorial, we discuss the usefulness of thing shadows in industrial IoT, by demonstrating how it keeps the pub/sub network alive even if the thing intermittently goes offline."
}
</script>

  

  

  

  





  <title>Thing Shadows with AWS IoT | anders e</title>
</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="page-wrapper   " data-wc-page-id="3a1d449bc45ddd41d35b31299b6c1f03" >

  
  
  
  
  
  
  
  
  <script src="../../js/wowchemy-init.min.a8a181ea67095ef9fbb0e99ffbf585a0.js"></script>

  


<aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#" aria-label="Close"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control"
        aria-label="Search...">
        
      </div>

      
      

      

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>



  <div class="page-header">
    












<nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
  <div class="container-xl">

    
    <div class="d-none d-lg-inline-flex">
      <a class="navbar-brand" href="../../">anders e</a>
    </div>
    

    
    <button type="button" class="navbar-toggler" data-toggle="collapse"
            data-target="#navbar-content" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span><i class="fas fa-bars"></i></span>
    </button>
    

    
    <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
      <a class="navbar-brand" href="../../">anders e</a>
    </div>
    

    
    
    <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

      
      <ul class="navbar-nav d-md-inline-flex">
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
            
            
            
              
            
            
          
        

        <li class="nav-item">
          <a class="nav-link " href="../../#projects"><span>Projects</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="../../post/"><span>Blog</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="../../about/"><span>About</span></a>
        </li>

        
        

      

        
      </ul>
    </div>

    <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">

      
      
        
      

      
      
      <li class="nav-item">
        <a class="nav-link js-search" href="#" aria-label="Search"><i class="fas fa-search" aria-hidden="true"></i></a>
      </li>
      

      
      
      <li class="nav-item dropdown theme-dropdown">
        <a href="#" class="nav-link" data-toggle="dropdown" aria-haspopup="true" aria-label="Display preferences">
          <i class="fas fa-moon" aria-hidden="true"></i>
        </a>
        <div class="dropdown-menu">
          <a href="#" class="dropdown-item js-set-theme-light">
            <span>Light</span>
          </a>
          <a href="#" class="dropdown-item js-set-theme-dark">
            <span>Dark</span>
          </a>
          <a href="#" class="dropdown-item js-set-theme-auto">
            <span>Automatic</span>
          </a>
        </div>
      </li>
      

      
      

    </ul>

  </div>
</nav>


  </div>

  <div class="page-body">
    <article class="article article-project">

  




















  
  
    
  


<div class="article-container pt-3">
  <h1>Thing Shadows with AWS IoT</h1>

  

  


<div class="article-metadata">

  
  

  
  <span class="article-date">
    
    
      
    
    2020-06-16
  </span>
  

  

  

  
  
  
  
  
  

  
  

</div>

  




<div class="btn-links mb-3">
  
  








  


















  
  
  
    
  
  
  
  
  
    
  
  <a class="btn btn-outline-primary btn-page-header" href="https://github.com/AnHosu" target="_blank" rel="noopener">
    <i class="fab fa-github mr-1"></i>
    Go to project repo
  </a>

  
  
  
    
  
  
  
  
  
    
    
      
    
  
  <a class="btn btn-outline-primary btn-page-header" href="../../project/iot-poc/" >
    <i class="fas fa-network-wired mr-1"></i>
    iIoT Meta Post
  </a>


</div>


</div>


<div class="article-header article-container featured-image-wrapper mt-4 mb-4" style="max-width: 720px; max-height: 497px;">
  <div style="position: relative">
    <img src="../../project/iot-poc-shadow/featured_hu6ee9a4dbf5976cd748f6bd821a33e0c7_144738_720x0_resize_lanczos_3.png" alt="" class="featured-image">
    
  </div>
</div>



  <div class="article-container">

    <div class="article-style">
      <p>On its own, a Thing Shadow might not look like much or even that useful. It certainly is an extra layer of complexity on top of publishing and subscribing. Shadows are, however, the foundation on which we can build Digital Twins and are an almost neccessity for applications that run machine learning models on IoT data.<br><br>
So what exactly is the Shadow of a thing? In a moment we will dive into the technical details, but we can think of a Shadow as an entity that has the same abilities as a thing, it can send and receive messages, except that it is always an exact copy of the latest state of the thing. If the thing goes offline, the Shadow will still be there reporting the latest state. A Shadow is purely a software construct, there is no hardware, but it can live in the cloud, on the edge, or both.<br><br>
Before we get started, it should be said that the <a href="https://docs.aws.amazon.com/iot/latest/developerguide/iot-device-shadows.html" title="AWS thing shadow docs" target="_blank" rel="noopener">documentation</a> for Shadows is quite good and definitely worth a read. Instead of repeating the documentation, we will expand on the previous demonstrations of <a href="../../project/iot-poc-publishing/" title="Publishing demonstration">publishing</a> and <a href="../../project/iot-poc-pubsub/" title="pub/sub demonstration">subscribing</a> with AWS IoT and MQTT messages, to include a cloud based Shadow of our thing, the BME680 sensor. That is, we will not exemplify all of the Shadow functionality, rather we will get started using Shadows with an example that is as simple in functionality as possible. Once we are done with this case, we will have come far enough to start understanding how advanced functions and applications work.<br><br>
We will try to do build a thing that does something along the lines of</p>
<pre><code>Prepare the sensor
Set up connection to AWS
while true
    get a sensor reading
    update the Shadow
    publish the reading
    confirm that the Shadow was updated
</code></pre>
<p>We will then look at the Shadow document using the AWS IoT test functionality.</p>
<div align="center">
	<img width=500 src="../iot-poc/images/shadow_architecture.png" alt="iot setup">
  Schematic of the architecture we are building in this demonstration.
</div>
<h1 id="basics-of-device-shadows">Basics of Device Shadows</h1>
<p>The Shadow of a thing is a JSON document containing predetermined fields. All devices registered in AWS IoT are given the Shadow functionality by default, though the JSON is only generated the first time the Shadow is updated. An example of a Shadow document could be</p>
<pre><code class="language-json">{
    &quot;state&quot;:{
      &quot;reported&quot;:{
        &quot;value&quot;: 27.87
      }
    },
    &quot;metadata&quot;:{
      &quot;reported&quot;:{
        &quot;value&quot;:{
          &quot;timestamp&quot;:1583755496
        }
      }
    },
    &quot;version&quot;:4,
    &quot;timestamp&quot;:1583755643
}
</code></pre>
<p>Let us walk through each of the fields one at a time.<br><br>
<code>state</code> holds the current values of the thing. The <code>reported</code> field should hold the current values as reported by the device itself. It can hold any number of reporting fields and a field can be an array.<br>
Besides <code>reported</code> the <code>state</code> field can also hold a <code>desired</code> field which can hold desired values as requested by an application or another device. This could be useful if we were doing a case with automation or maybe a home IoT project.<br><br>
This could be the state of a thing consisting of a valve and a flow meter where an application or maybe a user has just requested a new state:</p>
<pre><code class="language-json">{
    &quot;state&quot;:{
      &quot;reported&quot;:{
        &quot;flow&quot;: 15.04,
        &quot;valve_state&quot;: &quot;open&quot;
      },
      &quot;desired&quot;:{
          &quot;flow&quot;: 0,
          &quot;valve_state&quot;: &quot;closed&quot;
      }
    }
}
</code></pre>
<p>We will not use the desired field for this demonstration. We will just report the latest temperature of our Thing like this</p>
<pre><code class="language-json">{
    &quot;state&quot;:{
      &quot;reported&quot;: { &quot;temperature&quot; : 21.6 }
    }
}
</code></pre>
<p>The <code>metadata</code> field holds information on when each of the values in the <code>state</code> field were updated. The field follows the same schema as <code>state</code> and the information is given as a UTC timestamp, representing when the value was last updated.<br><br>
The <code>version</code> field is a super useful feature. It is an integer that increases every time an update is made to the document, allowing applications and devices to know whether their local copy is the latest.<br><br>
The <code>timestamp</code> field indicates the UTC timestamp of when the update was transmitted from AWS IoT.<br><br>
Fields that are set to <code>Null</code> are deleted from the Shadow document rather than reporting the <code>Null</code>.<br><br>
There are few additional features in Shadow document and they are neatly described in the <a href="https://docs.aws.amazon.com/iot/latest/developerguide/device-shadow-document.html" title="Shadow document developer guide" target="_blank" rel="noopener">developer guide</a>. For now, we have all we need to get started.</p>
<h2 id="update-a-device-shadow">Update a Device Shadow</h2>
<p>Updating the Shadow of a device is done by sending a message to a specific topic. The topic is in the format <code>$aws/things/yourDevice/shadow/update</code> and depends on the name of the device registered in AWS IoT. If our device was called &lsquo;factory3Airflow&rsquo; then the topic would be <code>$aws/things/factory3Airflow/shadow/update</code>.<br>
The update message might look something like this</p>
<pre><code class="language-json">{
    &quot;state&quot;: {
        &quot;reported&quot;: {
            &quot;flow&quot;: 2.6
        }
    }
} 
</code></pre>
<p>Coding such a flow is quite similar to what we did for <a href="../../project/iot-poc-publishing/" title="publishing case">publishing</a>, except the topic is a bit more elaborate. Assuming that the client ID is the same as the device name, we can configure a connection and start updating the Shadow like this:</p>
<pre><code class="language-python"># Define neccessary topics
topic_update = &quot;$aws/things/&quot; + clientId + &quot;/shadow/update&quot;

# Configure connection to AWS IoT
# ...

# Keep updating the Shadow on an infinite loop
while True:
    message = {}
    temperature = get_sensor_reading()
    message[&quot;state&quot;] = { &quot;reported&quot; : {&quot;temperature&quot; : temperature } }
    messageJson = json.dumps(message)
    # Update the Shadow
    myAWSIoTMQTTClient.publish(topic_update, messageJson, 1)
    time.sleep(30)
</code></pre>
<p>This is fine and all but how do we know that it works?</p>
<h2 id="subscribing-to-shadow-updates">Subscribing to Shadow Updates</h2>
<p>Whenever a Shadow is successfully updated, it generates and publishes a message to the topic <code>$aws/things/yourDevice/shadow/update/accepted</code>. Once again, the exact name changes based on our device name. By subscribing to this specific topic with QoS = 1, our device or application can recieve updates whenever there are changes to the Shadow.<br><br>
Another useful topic to subscribe to is <code>$aws/things/yourDevice/shadow/update/rejected</code>. A message is published to this topic whenever an update fails and can thus provide excellent feedback for an application or for debugging.<br><br>
We can subscribe to these topics just like we would any other topics. Again assuming that the client ID is identical to the device name, it might look something like this:</p>
<pre><code class="language-python"># Define neccessary topics
topic_update = &quot;$aws/things/&quot; + clientId + &quot;/shadow/update&quot;

# Configure connection to AWS IoT
# ...

# Specify what to do, when we receive an update
def callback_update_accecpted(client, userdata, message):
    # Just print the message
    print(&quot;Got an update, on the topic:&quot;)
    print(message.topic)
    print(&quot;The message is this&quot;)
    print(message.payload)

# Specify what to do, when the update is rejected
def callback_update_rejected(client, userdata, message):
    # Just print the message
    print(&quot;The update was rejected. Received the following message:&quot;)
    print(message.payload)

# Subscribe
myAWSIoTMQTTClient.subscribe(topic_update + &quot;/accepted&quot;, 1, callback_update_accepted)
myAWSIoTMQTTClient.subscribe(topic_update + &quot;/rejected&quot;, 1, callback_update_rejected)
</code></pre>
<h2 id="policies-for-shadows">Policies for Shadows</h2>
<p>Before we move on to more Shadow related topics, we should take a look at the policies needed to allow devices and applications to utilise these special topics. Once again, the documentation is quite substantial and even provides <a href="https://docs.aws.amazon.com/iot/latest/developerguide/device-shadow-mqtt.html" title="Shadow policy examples" target="_blank" rel="noopener">specific examples</a> for policies related to Shadow interaction. Here we will focus on constructing an example.<br><br>
Imagine we have a device registered with the name <code>my_sensor</code> in AWS IoT. We would like to give the device access to establish a connection with AWS IoT, publish readings to the topic <code>my_sensor/reading</code>, update its Shadow, and subscribe to the accepted and rejected responses generated on Shadow update.<br>
We already know how to construct statements to allow connection and publishing.</p>
<pre><code class="language-json">{
  &quot;Statement&quot;: [
    {
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Action&quot;: [ &quot;iot:Publish&quot; ],
      &quot;Resource&quot;: [
        &quot;arn:aws:iot:your-region:your-aws-account:topic/my_sensor/reading&quot;
      ]
    },
    {
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Action&quot;: [ &quot;iot:Connect&quot; ],
      &quot;Resource&quot;: [ 
        &quot;arn:aws:iot:your-region:your-aws-account:client/my_sensor&quot; 
      ]
    }
  ]
}
</code></pre>
<p>To allow the desired Shadow interactions, we will add another resource to the publish action, mentioning the topic <code>$aws/things/my_sensor/shadow/update</code>:<br></p>
<pre><code class="language-json">{
  &quot;Statement&quot;: [
    {
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Action&quot;: [ &quot;iot:Publish&quot; ],
      &quot;Resource&quot;: [
        &quot;arn:aws:iot:your-region:your-aws-account:topic/my_sensor/reading&quot;,
        &quot;arn:aws:iot:your-region:your-aws-account:topic/$aws/things/my_sensor/shadow/update&quot;
      ]
    }
  ]
}
</code></pre>
<p>To allow subscription we will add subscription and receive actions for two resources - one for each topic.</p>
<pre><code class="language-json">{
  &quot;Statement&quot;: [
    {
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Action&quot;: [ &quot;iot:Subscribe&quot; ],
      &quot;Resource&quot;: [
        &quot;arn:aws:iot:your-region:your-aws-account:topicfilter/$aws/things/my_sensor/shadow/update/accepted&quot;,
        &quot;arn:aws:iot:your-region:your-aws-account:topicfilter/$aws/things/my_sensor/shadow/update/rejected&quot;
      ]
    },
    {
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Action&quot;: [ &quot;iot:Receive&quot; ],
      &quot;Resource&quot;: [
        &quot;arn:aws:iot:your-region:your-aws-account:topic/$aws/things/my_sensor/shadow/update/accepted&quot;,
        &quot;arn:aws:iot:your-region:your-aws-account:topic/$aws/things/my_sensor/shadow/update/rejected&quot;
      ]
    }
  ]
}
</code></pre>
<p>Given that the two subscription topics have the same root and that there are more <code>update/</code> topics to subsrcibe to, it is tempting to add something along the lines of <code>$aws/things/my_sensor/shadow/update/*</code>, giving a wildcard for anything below the update root. While this would indeed work as intended now, AWS reserves the right to add additional reserved topics to the existing structure. If we were to use a policy with this type of wildcard, we thus risk allowing access to future topics causing unintended behaviour or information breaches. Therefore AWS discourages the use of wildcards in this way.<br>
Our final policy looks like this:</p>
<pre><code class="language-json">{
  &quot;Version&quot;: &quot;2012-10-17&quot;,
  &quot;Statement&quot;: [
    {
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Action&quot;: [ &quot;iot:Publish&quot; ],
      &quot;Resource&quot;: [
        &quot;arn:aws:iot:your-region:your-aws-account:topic/my_sensor/reading&quot;,
        &quot;arn:aws:iot:your-region:your-aws-account:topic/$aws/things/my_sensor/shadow/update&quot;
      ]
    },
    {
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Action&quot;: [ &quot;iot:Connect&quot; ],
      &quot;Resource&quot;: [ 
        &quot;arn:aws:iot:your-region:your-aws-account:client/my_sensor&quot; 
      ]
    },
    {
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Action&quot;: [ &quot;iot:Subscribe&quot; ],
      &quot;Resource&quot;: [
        &quot;arn:aws:iot:your-region:your-aws-account:topicfilter/$aws/things/my_sensor/shadow/update/accepted&quot;,
        &quot;arn:aws:iot:your-region:your-aws-account:topicfilter/$aws/things/my_sensor/shadow/update/rejected&quot;
      ]
    },
    {
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Action&quot;: [ &quot;iot:Receive&quot; ],
      &quot;Resource&quot;: [
        &quot;arn:aws:iot:your-region:your-aws-account:topic/$aws/things/my_sensor/shadow/update/accepted&quot;,
        &quot;arn:aws:iot:your-region:your-aws-account:topic/$aws/things/my_sensor/shadow/update/rejected&quot;
      ]
    }
  ]
}
</code></pre>
<h1 id="simple-shadow-updating">Simple Shadow Updating</h1>
<p>Now we have everything we need to build a full demonstration of Shadow interaction. We know that we can structure the interaction in exactly the same way as with regular publishing and subscribing but with two key differences. The first is that we will publish and subscribe to the specific Shadow topics. The second is that our published message follows the Shadow document schema. Here is an example; We can have our callback functions do whatever we want, but I just wrote out some simple print statements:</p>
<pre><code class="language-python"># Define topic for updates
topic_update = &quot;$aws/things/&quot; + clientId + &quot;/shadow/update&quot;

# Configure connection to AWS IoT
# ...

# Specify what to do, when we receive an update
def callback_update_accepted(client, userdata, message):
    # Just print the message
    print(&quot;Got an update, on the topic:&quot;)
    print(str(message.topic))
    print(&quot;The message is this&quot;)
    print(str(message.payload))

# Specify what to do, when the update is rejected
def callback_update_rejected(client, userdata, message):
    # Just print the message
    print(&quot;The update was rejected. Received the following message:&quot;)
    print(str(message.payload))

# Subscribe
myAWSIoTMQTTClient.subscribe(topic_update + &quot;/accepted&quot;, 1, callback_update_accepted)
time.sleep(2)
myAWSIoTMQTTClient.subscribe(topic_update + &quot;/rejected&quot;, 1, callback_update_rejected)
time.sleep(2)
# Publish to the same topic in a loop forever
while True:    
    message = {}
    if sensor.get_sensor_data():
        temperature = sensor.data.temperature
    else:
        temperature = None
    message[&quot;state&quot;] = { &quot;reported&quot; : {&quot;temperature&quot; : temperature } }
    messageJson = json.dumps(message)
    # Update the Shadow
    myAWSIoTMQTTClient.publish(topic_update, messageJson, 1)
    time.sleep(15)
</code></pre>
<p>The full working script is <a href="https://github.com/AnHosu/iot_poc/blob/master/example_scripts/shadow.py" title="Shadow example" target="_blank" rel="noopener">here</a>. Remember that the clientID is assumed to be the name of the thing. We could register a thing called <code>my_sensor</code> in AWS IoT and give its certificate a policy like the one we developed above. Then we can run this script on our Raspberry Pi with the BME680 sensor. Like this:</p>
<pre><code class="language-bash">python3 shadow.py -e &lt;your aws iot endpoint&gt; -r &lt;file containing root certificate&gt; -c &lt;file containing device certificate&gt; -k &lt;file containing private key&gt; -id &lt;a client ID&gt;
</code></pre>
<p>With this, we are publishing the latest sensor readings directly to the Shadow and then regurgitating the message generated when the update is accepted or rejected. When it works, the output should look something like this:</p>
<pre><code>Got an update, on the topic:
$aws/things/my_sensor/shadow/update/accepted
The message is this
b'{&quot;state&quot;:{&quot;reported&quot;:{&quot;temperature&quot;:35.48}},&quot;metadata&quot;:{&quot;reported&quot;:{&quot;temperature&quot;:{&quot;timestamp&quot;:1584104617}}},&quot;version&quot;:99,&quot;timestamp&quot;:1584104617}'
</code></pre>
<p>If your setup is not working, make sure to check exactly which component is failing. If you are getting errors in the connection part, check whether your keys are for the right certificate and whether the certificate is activated. If you are getting an error in the subscription or publishing parts, check whether your policy gives the right accesses. Finally, you should not get any messages on the <code>/update/rejected</code> subject. If you do, one possible reason is that the message follows a wrong format.<br><br></p>
<h1 id="more-shadow-topics">More Shadow Topics</h1>
<p>Congratulations! You now know how to set up a Shadow for your device and you are ready to start building the foundation for your digital twin application. There are, however, a couple of extra details that you might want to know about before you start building the application.<br></p>
<h2 id="get-the-shadow">Get the Shadow</h2>
<p>If our application just listens to the <code>/update/accepted</code> we will have achieved nothing more by going through the Shadow compared to just plain publishing. The real power of Shadows is in always having the latest reading from our device available, while decoupling the device and the application.<br>
Now that we are having the device update its Shadow each time a new reading is available, we can start having our application access that Shadow document whenever it needs it. We can always view the Shadow document of our thing by going to AWS IoT &gt; Manage &gt; Things, then selecting our device and go to the &lsquo;Shadow&rsquo; tab</p>
<div align="center">
	<img width=500 src="../iot-poc/images/aws_shadow_document.png" alt="Shadow document">
</div>
<p>This is nice for demonstration and debugging purposes, but our application needs to access the document programatically. The MQTT protocol does not do requests, and operates using the publish and subscribe model only. So the way for our application to request the Shadow document on demand is to publish a request to a specific topic and subscribe to a response topic. Note that there is an alternative based on a REST API, which we will discuss in a <a href="shadow.md#in-production">section</a> below, but for now we will stick to the MQTT way.
By sending an empty request, <code>{}</code>, to the topic <code>$aws/things/yourDevice/shadow/get</code> our application can trigger the Shadow to publish a copy of the current Shadow document to the subject <code>$aws/things/yourDevice/shadow/get/accepted</code>. The easiest way to see it in action is by subscribing to the <code>$aws/things/yourDevice/shadow/get/#</code> topicfilter in the test console and then publish an empty message to <code>/get</code>. I gave it a try here</p>
<div align="center">
	<img width=500 src="../iot-poc/images/aws_shadow_get.png" alt="Shadow get">
</div>
<p>This is also an excellent opportunity to explore what happens, when we do something unexpected. Here I published a string instead of a JSON, for instance:</p>
<div align="center">
	<img width=500 src="../iot-poc/images/aws_shadow_get_rejected.png" alt="Shadow get">
</div>
<p>The <code>/get</code> topic also has a <code>/rejected</code> subtopic that gives helpful error messages when requests are rejected.</p>
<h2 id="delete-the-shadow">Delete the Shadow</h2>
<p>We now know how to update and get the Shadow document. Now we just need to know how to delete it. By publishing an empty message to the topic <code>$aws/things/yourDevice/shadow/delete</code> we delete the Shadow document for <code>yourDevice</code>. On successful deletion, a confirmation is published to <code>/delete/accepted</code> and a message is published to <code>/delete/rejected</code> otherwise. Let us try to delete the Shadow, then try to get it, and see what happens:</p>
<div align="center">
	<img width=500 src="../iot-poc/images/aws_shadow_delete.png" alt="shadow delete">
</div>
<div align="center">
	<img width=500 src="../iot-poc/images/aws_shadow_delete_get.png" alt="shadow delete get">
</div>
<p>We get an error message because there is no Shadow document to get.</p>
<h2 id="shadow-mqtt-topics-summary">Shadow MQTT Topics Summary</h2>
<p>In summary, all Shadow interaction topics are prefixed with <code>$aws/things/yourDevice/shadow</code> where <code>yourDevice</code> is the ID of our thing as registered in AWS IoT. We interact with the Shadow in three ways: we can update the Shadow, get the Shadow, or delete the Shadow. These functions are triggered when messages are published to the topics <code>/update</code>, <code>/get</code>, or <code>/delete</code> repectively. When the actions succeed, messages are published to the <code>/accepted</code> subtopic. When the actions fail, messages are published to the <code>/rejected</code> subtopic with useful information for debugging.<br>
Not covered in this demonstration are the <code>/update/document</code> and <code>/update/delta</code> topics. The <a href="https://docs.aws.amazon.com/iot/latest/developerguide/device-shadow-mqtt.html" title="Shadow interaction docs" target="_blank" rel="noopener">docs</a> have more about Shadow interaction topics along with sample example policies.</p>
<h2 id="the-shadow-client">The Shadow Client</h2>
<p>Depending on the apllication and how we manage topics, it might be easier to use the special Shadow client that is included in the SDK. The Shadow client, once configured, takes care of publishing and subscribing to the right topics. That is, it does exactly what we did above but with fewer lines of code and without us having to state the topics explicitly.<br>
The client is configured and connected like any other MQTT client:</p>
<pre><code class="language-python">from AWSIoTPythonSDK.MQTTLib import AWSIoTMQTTShadowClient

myAWSIoTMQTTShadowClient = AWSIoTMQTTShadowClient(clientId)
myAWSIoTMQTTShadowClient.configureEndpoint(host, port)
myAWSIoTMQTTShadowClient.configureCredentials(rootCAPath, privateKeyPath, certificatePath)
myAWSIoTMQTTShadowClient.configureAutoReconnectBackoffTime(1, 32, 20)
myAWSIoTMQTTShadowClient.configureConnectDisconnectTimeout(10)
myAWSIoTMQTTShadowClient.configureMQTTOperationTimeout(5)
myAWSIoTMQTTShadowClient.connect()
</code></pre>
<p>Now we create a handler, that takes care of the publishing and subscribing. All we have to do is pass it the name of the Thing, which we will assume is the same as the client ID:</p>
<pre><code class="language-python"># Handles publishing and subscribing to Shadow topics
# Persists subscription
deviceShadowHandler = myAWSIoTMQTTShadowClient.createShadowHandlerWithName(clientID, True)
</code></pre>
<p>The handler will subscribe to the response topics from the Shadow. By setting the second argument to True, we are telling the handler to persist the subscription, i.e. not close the subscription when a response is received. Depending on the application, it might be neccessary to close the subscription once a response is received. But since we only have one client interacting with the Shadow in our case, we can safely persist the subscription and avoid resubscribing every time we send an update.<br>
As with every other subscription, we need to tell the client what to do when a message is received with a callback function. The callback function is provided to the handler when we perform an update, but before we get there we need to actually define a function. The callback function for a Shadow client looks a bit different from the callback functions we saw for regular subscribing. It has a <code>payload</code> object, which contains the Shadow document, assuming that the update is accepted. It then has a <code>responseStatus</code> string, which can be either <code>&quot;timeout&quot;</code>, <code>&quot;accepted&quot;</code>, or <code>&quot;rejected&quot;</code> depending on how the update event went. Finally there is a <code>token</code> which can be used to trace the request, but we will not discuss it here. Here is an example of a callback function for an update request.</p>
<pre><code class="language-python">import json

def shadow_callback_update(payload, responseStatus, token):
    if responseStatus == &quot;timeout&quot;:
        print(&quot;The update request timed out.&quot;)
    if responseStatus == &quot;accepted&quot;:
        payloadDict = json.loads(payload)
        print(&quot;The update request was accepted, here is the new state:&quot;)
        print(payloadDict[&quot;state&quot;])
    if responseStatus == &quot;rejected&quot;:
        print(&quot;The update request was rejected.&quot;)
</code></pre>
<p>Finally, we can start updating the Shadow. The message still has to follow the Shadow document syntax:</p>
<pre><code class="language-python">while true:
    message = {}
    temperature = get_temperature() # Dummy function
    message[&quot;state&quot;] = { &quot;reported&quot; : {&quot;temperature&quot; : temperature } }
    deviceShadowHandler.shadowUpdate(json.dumps(message), shadow_callback_update, 6)
    time.sleep(5)
</code></pre>
<p>This will send an update to the reported temperature state of the Shadow document. The handler will time out after six seconds, as specified in the third argument. The handler will then wait for the response and invoke the callback function once a response is received.</p>
<h1 id="in-production">In Production</h1>
<p>This section is not part of the demonstration as such. It is but a short discussion of some of the considerations we might take when bringing the Shadow feature into production. There are not many addtional considerations besides those discussed for <a href="../../project/iot-poc-publishing/#in-production">publishing</a> and <a href="../../project/iot-poc-pubsub/#in-production">subscribing</a>, but here are some of them.</p>
<h2 id="decouple-application-and-data-stream">Decouple Application and Data Stream</h2>
<p>In order for Shadows to be a boon and not just an added operational burden, it is important that we develop applications that utilise it properly. An example of an application that might benefit greatly from using Shadows is one that relies on machine learning models to predict outcomes for displaying or acting on. A machine learning algorithm needs all its features at the same time to produce a prediction, whereas the physical reality of our sensing equipment is that different features are reported at differing times and at different frequencies. Instead of having a large layer of business logic in front of the machine learning algorithm, the application could just serve the latest values as stored in the Shadow. This effectively decouples the data stream and the machine learning model, ensuring that our application can keep running even if a device is broken.</p>
<div align="center">
	<img width=500 src="../iot-poc/images/shadow_flow.png" alt="iot setup">
  This is a general view of how a Shadow could fit into the larger IoT.
</div>
<h2 id="shadow-http-interactions">Shadow HTTP Interactions</h2>
<p>Chances are that we do not want our application to deal with the MQTT protocol. The publish subscribe model works well for the IoT part where data is flowing to and from multiple sources to multiple targets. Our application, however, often just needs the latest piece of data, and it is a bit of hassle to deal with an MQTT client, publishing, and subscribing just to get a single piece of data once in a while.<br>
One of the major advantages of the Shadow functionality is that each Shadow exposes a <a href="https://docs.aws.amazon.com/iot/latest/developerguide/device-shadow-rest-api.html" target="_blank" rel="noopener">REST API</a> to which we can send regular HTTP requests and retrieve data.<br>
The API is exposed at</p>
<pre><code>https://endpoint/things/yourDevice/shadow
</code></pre>
<p>Where the <code>endpoint</code> is our custom AWS IoT endpoint and <code>yourDevice</code> is the name of our Thing as registered in AWS IoT. We can send regular Get, Update, and Delete HTTP requests to this endpoint and get, update, or delete the Shadow correspondingly. Note though that the entity sending the requests must have permissions to do so. This can be achieved with an IAM user with proper policies.</p>

    </div>

    






<div class="article-tags">
  
  <a class="badge badge-light" href="../../tag/iot/">IoT</a>
  
  <a class="badge badge-light" href="../../tag/data/">Data</a>
  
  <a class="badge badge-light" href="../../tag/data-engineering/">Data Engineering</a>
  
</div>













  
  



  
  
  
    
  
  
  
  <div class="media author-card content-widget-hr">
    
      
      <a href="../../"><img class="avatar mr-3 avatar-circle" src="../../author/anders-e.-nielsen/avatar_huaf22d72e35256be9d48177f1f21d9377_326351_270x270_fill_q75_lanczos_center.jpg" alt="Anders E. Nielsen"></a>
    

    <div class="media-body">
      <h5 class="card-title"><a href="../../">Anders E. Nielsen</a></h5>
      <h6 class="card-subtitle">Data Professional &amp; Research Scientist</h6>
      <p class="card-text">I apply modern data technology to solve real-world problems. My interests include statistics, machine learning, computational biology, and IoT.</p>
      <ul class="network-icon" aria-hidden="true">
  
    
    
    
      
    
    
    
    
    
    <li>
      <a href="mailto:andellegaard@gmail.com" >
        <i class="fas fa-envelope"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://www.linkedin.com/in/anders-ellegaard-nielsen-6a0857125/" target="_blank" rel="noopener">
        <i class="fab fa-linkedin"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://github.com/AnHosu" target="_blank" rel="noopener">
        <i class="fab fa-github"></i>
      </a>
    </li>
  
</ul>

    </div>
  </div>
















  
  
  <div class="article-widget content-widget-hr">
    <h3>Related</h3>
    <ul>
      
      <li><a href="../../project/iot-poc-greengrass/">Build an Edge with Greengrass</a></li>
      
      <li><a href="../../project/iot-poc/">Industrial IoT with AWS and Python</a></li>
      
      <li><a href="../../project/iot-poc-greengrass-ml/">Machine Learning at the Edge and other Advanced Features of Greengrass</a></li>
      
      <li><a href="../../project/iot-poc-publishing/">Publishing Industrial Data with AWS IoT</a></li>
      
      <li><a href="../../project/iot-poc-pubsub/">Publishing and Subscribing with AWS IoT</a></li>
      
    </ul>
  </div>
  





    <div class="project-related-pages content-widget-hr">
      
      

      
      
      

      
      
      

      
      
      
    </div>
  </div>
</article>
  </div>

  <div class="page-footer">
    
    
    <div class="container">
      <footer class="site-footer">

  

  

  
  <p class="powered-by">
    © 2021 Anders E. Nielsen
  </p>
  

  
  






  <p class="powered-by">
    
    
    
      
      
      
      
      
      
      
      
      Published with <a href="https://wowchemy.com/?utm_campaign=poweredby" target="_blank" rel="noopener">Wowchemy</a>, <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a>, and <a href="https://github.com/rstudio/blogdown" target="_blank" rel="noopener">R Blogdown</a>.
    
  </p>
</footer>

    </div>
    
  </div>

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

      

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.1.0/instantpage.min.js" integrity="sha512-1+qUtKoh9XZW7j+6LhRMAyOrgSQKenQ4mluTR+cvxXjP1Z54RxZuzstR/H9kgPXQsVB8IW7DMDFUJpzLjvhGSQ==" crossorigin="anonymous"></script>

      
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      

      
      

      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js" integrity="sha512-TDKKr+IvoqZnPzc3l35hdjpHD0m+b2EC2SrLEgKDRWpxf2rFCxemkgvJ5kfU48ip+Y+m2XVKyOCD85ybtlZDmw==" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/r.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/python.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/latex.min.js"></script>
        
      

    

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.min.js" integrity="sha512-SeiQaaDh73yrb56sTW/RgVdi/mMqNeM2oBwubFHagc5BkixSpP1fvqF47mKzPGWYSSy4RwbBunrJBQ4Co8fRWA==" crossorigin="anonymous"></script>
    

    
    

    
    
    
      
      <script id="search-hit-fuse-template" type="text/x-template">
        <div class="search-hit" id="summary-{{key}}">
          <div class="search-hit-content">
            <div class="search-hit-name">
              <a href="{{relpermalink}}">{{title}}</a>
              <div class="article-metadata search-hit-type">{{type}}</div>
              <p class="search-hit-description">{{snippet}}</p>
            </div>
          </div>
        </div>
      </script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
      
    

    
    

    
    
    
    

    
    <script src="../../js/bootstrap.bundle.min.6aed84840afc03ab4d5750157f69c120.js"></script>

    
    
      
      
      
      
      
      
      
    

    
    
    
    
    
    
    
    
      
      
    
    
    <script src="../../en/js/wowchemy.min.cf8ca859a9b74f8b1cd804621b13e5f1.js"></script>

    
  <script async defer src="https://buttons.github.io/buttons.js"></script>




</body>
</html>
