<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Biochemistry | anders e</title>
    <link>/tag/biochemistry/</link>
      <atom:link href="/tag/biochemistry/index.xml" rel="self" type="application/rss+xml" />
    <description>Biochemistry</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>© 2023 Anders E. Nielsen</copyright><lastBuildDate>Sat, 20 Nov 2021 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/media/icon_hu0b500a15011e1e483635372eebf6e1df_24681_512x512_fill_lanczos_center_3.png</url>
      <title>Biochemistry</title>
      <link>/tag/biochemistry/</link>
    </image>
    
    <item>
      <title>Bespoke Bayesian Model for Biochemical Assays</title>
      <link>/post/bespoke-biochem-one/</link>
      <pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate>
      <guid>/post/bespoke-biochem-one/</guid>
      <description>
&lt;script src=&#34;../../post/bespoke-biochem-one/index_files/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;I am on a quest to improve the model fitting I do on biochemical assays. For some time, I have had this feeling that I should be able to extract more information from the data gathered in biochemical assays, in particular assays with a high throughput. I have been using classical machine learning techniques and generic fitting and optimisation functions to interpret data from such assays. While this approach works, it also neglects much of the available domain expertise. Many of the underlying biochemical mechanisms are known and I would like my models to take that into account so I get results that are more directly interpretable in the context of the hypothesis that required the assay in the first place. In other words, I want a bespoke model.&lt;/p&gt;
&lt;p&gt;I will be developing the bespoke model one minimally viable step at a time. In this study, I am building a Bayesian model for biochemical assays where the underlying data generating process is the Hill equation for tissue responses &lt;span class=&#34;citation&#34;&gt;[&lt;a href=&#34;#ref-Neubig597&#34; role=&#34;doc-biblioref&#34;&gt;1&lt;/a&gt;]&lt;/span&gt;. I will then test the model in two simulated example studies.&lt;/p&gt;
&lt;p&gt;I was inspired to write this study after reading the chapter “Generalized Linear Madness” in the book Statistical Rethinking by R. McElreath &lt;span class=&#34;citation&#34;&gt;[&lt;a href=&#34;#ref-McElreath:2016&#34; role=&#34;doc-biblioref&#34;&gt;2&lt;/a&gt;]&lt;/span&gt; and the writings of M. Betancourt &lt;span class=&#34;citation&#34;&gt;[&lt;a href=&#34;#ref-Betancourt:2019&#34; role=&#34;doc-biblioref&#34;&gt;3&lt;/a&gt;]&lt;/span&gt;. For an introduction to bespoke Bayesian models, I highly recommend these resources.&lt;/p&gt;
&lt;p&gt;If you are following along, we will build the Bayesian models in Stan and make use of the Rstan interface to extract posterior samples. For data wrangling and visualisation, we will use the Tidyverse.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2)
library(magrittr)

options(mc.cores = parallel::detectCores())

colour &amp;lt;- list(
  orange_dark = &amp;quot;#fb8500&amp;quot;,
  orange_light = &amp;quot;#ffb703&amp;quot;,
  blue_dark = &amp;quot;#023047&amp;quot;,
  azure = &amp;quot;#219ebc&amp;quot;,
  blue_light = &amp;quot;#8ecae6&amp;quot;
)

set.seed(4444)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;contents&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Contents&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#contents&#34;&gt;Contents&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#domain-expertise&#34;&gt;Domain Expertise&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#hill-equation&#34;&gt;Hill Equation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#from-domain-expertise-to-probabilistic-model&#34;&gt;From Domain Expertise to Probabilistic Model&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#a-prior-for-the-hill-coefficient&#34;&gt;A prior for the Hill coefficient&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#a-prior-for-the-maximum-tissue-response&#34;&gt;A prior for the maximum tissue response&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#a-prior-for-the-minimum-tissue-response&#34;&gt;A prior for the minimum tissue response&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#a-prior-for-potency&#34;&gt;A prior for potency&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#a-prior-for-experiment-noise&#34;&gt;A prior for experiment noise&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#example-studies&#34;&gt;Example Studies&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#example-study-1---exploring-kinetics&#34;&gt;Example Study 1 - Exploring Kinetics&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#a-model-for-study-1&#34;&gt;A model for study 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#prior-predictive-check-in-tidyverse&#34;&gt;Prior predictive check in Tidyverse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#building-a-stan-model-for-study-1&#34;&gt;Building a Stan model for study 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#fitting-study-1&#34;&gt;Fitting study 1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#example-study-2---new-drug&#34;&gt;Example Study 2 - New Drug&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#a-model-for-study-2&#34;&gt;A model for study 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#prior-predictive-check-with-stan&#34;&gt;Prior predictive check with Stan&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#building-a-stan-model-for-study-2&#34;&gt;Building a Stan model for study 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#fitting-study-2&#34;&gt;Fitting study 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#assessing-posterior-quality&#34;&gt;Assessing posterior quality&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#comparing-to-another-fitting-method&#34;&gt;Comparing to another fitting method&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#next-steps&#34;&gt;Next Steps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#references&#34;&gt;References&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;domain-expertise&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Domain Expertise&lt;/h1&gt;
&lt;p&gt;Before we start coding a model or even looking at any data, let’s formally discuss the biochemical domain experitise.&lt;/p&gt;
&lt;div id=&#34;hill-equation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Hill Equation&lt;/h2&gt;
&lt;p&gt;When a ligand, e.g. a drug, is an antagonist to a receptor that causes some tissue response, the strength of that response, &lt;span class=&#34;math inline&#34;&gt;\(\mu_i\)&lt;/span&gt;, declines with increased concentration of that ligand, &lt;span class=&#34;math inline&#34;&gt;\([A_i]\)&lt;/span&gt;. The response is known to follow the Hill Equation &lt;span class=&#34;citation&#34;&gt;[&lt;a href=&#34;#ref-Neubig597&#34; role=&#34;doc-biblioref&#34;&gt;1&lt;/a&gt;]&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\mu_i = top - \frac{bottom - top}{1 + 10^{(\log_{10}(IC_{50}) - \log_{10}([A_i]))^{n_H}}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;When tissue response is plotted against log ligand concentration, the Hill equation is a downwards sloping S-curve where &lt;span class=&#34;math inline&#34;&gt;\(top\)&lt;/span&gt; is the maximum response and &lt;span class=&#34;math inline&#34;&gt;\(bottom\)&lt;/span&gt; is the minimum response. &lt;span class=&#34;math inline&#34;&gt;\(IC_{50}\)&lt;/span&gt; is the concentration at which the response is halfway between &lt;span class=&#34;math inline&#34;&gt;\(top\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(bottom\)&lt;/span&gt;. The final parameter, the Hill coefficient &lt;span class=&#34;math inline&#34;&gt;\(n_H\)&lt;/span&gt;, affects the steepness of the curve and is determined by the underlying kinetics. At &lt;span class=&#34;math inline&#34;&gt;\(n_H = 1\)&lt;/span&gt;, a ligand binding is independent of previously bound ligands. At &lt;span class=&#34;math inline&#34;&gt;\(n_H &amp;lt; 1\)&lt;/span&gt; binding has diminishing returns and at &lt;span class=&#34;math inline&#34;&gt;\(n_H &amp;gt; 1\)&lt;/span&gt; ligands cooperatively bind for increasing returns on tissue response.&lt;/p&gt;
&lt;p&gt;The Hill Equation appears in various forms in literature. Notably, when the ligand is an agonist, the curve has a positive slope and the halfway point is then often named &lt;span class=&#34;math inline&#34;&gt;\(EC_{50}\)&lt;/span&gt;. The logarithm base used could also be any other, but base 10 is a common choice, as 10 times dilutions or other whole-number dilutions are easier to make.&lt;/p&gt;
&lt;p&gt;Let’s plot an example curve&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;hill_function &amp;lt;- function(log_conc, bottom, top, log_IC50, nH) {
  top + (bottom - top)/(1 + 10^((log_IC50 - log_conc)*nH))
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bottom &amp;lt;- 0
top &amp;lt;- 1
log_IC50 &amp;lt;- -3
nH &amp;lt;- 1
ggplot() +
  xlim(log_IC50 - 3, log_IC50 + 3) +
  geom_function(
    fun = hill_function,
    args = list(bottom = bottom, top = top, log_IC50 = log_IC50, nH = nH),
    aes(colour = &amp;quot;Tissue response&amp;quot;)
  ) +
  labs(
    x = &amp;quot;log ligand concentration&amp;quot;,
    y = &amp;quot;response&amp;quot;,
    title = &amp;quot;Hill Equation Example&amp;quot;
  ) +
  scale_colour_manual(values = c(&amp;quot;Tissue response&amp;quot; = colour$azure)) +
  theme_minimal() +
  theme(legend.title = element_blank())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/bespoke-biochem-one/index_files/figure-html/hill_equation-1.png&#34; width=&#34;90%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;In the real world, we cannot sample the true tissue response exactly. As a proxy for the tissue response, we employ assays that are performed &lt;em&gt;in vitro&lt;/em&gt;. Such assays are sensitive to environmental conditions and, even in the most strictly controlled settings, yield noisy responses. Baring any systematic bias, the assay response, &lt;span class=&#34;math inline&#34;&gt;\(y_i\)&lt;/span&gt; should average to the true tissue response though.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;assay_response &amp;lt;- function(log_conc, bottom, top, log_IC50, nH, sigma) {
  noise &amp;lt;- rnorm(length(log_conc), 0, sigma)
  hill_function(log_conc, bottom, top, log_IC50, nH) + noise
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tibble::tibble(
  log_conc = seq(log_IC50 -3, log_IC50 + 3, length.out = 5),
  y = assay_response(log_conc, bottom, top, log_IC50, nH, (top - bottom)/20)
) %&amp;gt;% 
  ggplot(aes(log_conc, y)) +
  geom_point(aes(colour = &amp;quot;Noisy assay response&amp;quot;)) +
  geom_function(
    fun = hill_function,
    args = list(bottom = bottom, top = top, log_IC50 = log_IC50, nH = nH),
    aes(colour = &amp;quot;Tissue response&amp;quot;)
  ) +
  scale_colour_manual(values = c(
    &amp;quot;Tissue response&amp;quot; = colour$azure,
    &amp;quot;Noisy assay response&amp;quot; = colour$orange_light
  )) +
  labs(
    x = &amp;quot;log ligand concentration&amp;quot;,
    y = &amp;quot;response&amp;quot;,
    colour = &amp;quot;&amp;quot;
  ) +
  theme_minimal()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/bespoke-biochem-one/index_files/figure-html/noisy_assay_response-1.png&#34; width=&#34;90%&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;from-domain-expertise-to-probabilistic-model&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;From Domain Expertise to Probabilistic Model&lt;/h2&gt;
&lt;p&gt;With the basic domain knowledge in place, we are ready to start thinking about the assay in terms of probability distributions.&lt;/p&gt;
&lt;p&gt;The first expression relates our observed assay responses, &lt;span class=&#34;math inline&#34;&gt;\(y_i\)&lt;/span&gt;, to the true underlying tissue response, &lt;span class=&#34;math inline&#34;&gt;\(\mu_i\)&lt;/span&gt;. Given repeat observations, the assay response should average to the tissue response and the variance should be small and finite, so it is not too far a stretch to think of the assay response as a sample from a normal distribution.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[y_i \sim {\sf Normal}(\mu_i, \sigma)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Where &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt; is a parameter that is shared among all observations.&lt;/p&gt;
&lt;p&gt;We already know how the tissue response relates to the ligand concentration, &lt;span class=&#34;math inline&#34;&gt;\([A_i]\)&lt;/span&gt;, the variable of our assay; it is the Hill equation.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\mu_i = top - \frac{bottom - top}{1 + 10^{(\log_{10}(IC_{50}) - \log_{10}([A_i]))^{n_H}}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;These two expressions define our observational model or likelihood function. Next, we need to specify our prior model, and this is where domain expertise comes in handy.&lt;/p&gt;
&lt;p&gt;The prior model needs to have prior assumptions and corresponding distributions for each parameter in the model. The parameters that need priors are &lt;span class=&#34;math inline&#34;&gt;\(IC_{50}\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(bottom\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(top\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(n_H\)&lt;/span&gt;, and &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(\mu_i\)&lt;/span&gt; is an unobserved variable - it is a deterministic function of the model parameters and our variable, &lt;span class=&#34;math inline&#34;&gt;\([A_i]\)&lt;/span&gt;, so it does not need a prior.&lt;/p&gt;
&lt;p&gt;The priors will always have to be specific to the assay at hand. In this study, we are not considering a real assay, but will be simulating instead. Even so, we can still discuss general prior strategies for parameters of the model, in the light of our general knowledge about the biochemical processes. Later, when we start simulating, we can lock in specific priors.&lt;/p&gt;
&lt;p&gt;Let’s consider each parameter in turn, starting with &lt;span class=&#34;math inline&#34;&gt;\(n_H\)&lt;/span&gt;.&lt;/p&gt;
&lt;div id=&#34;a-prior-for-the-hill-coefficient&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;A prior for the Hill coefficient&lt;/h3&gt;
&lt;p&gt;The Hill coefficient will in many cases be well known. For instance, if the receptor that causes the tissue response is known to have only one binding site for the ligand, it extremely unlikely that we will observe any cooperative or competitive kinetics.&lt;/p&gt;
&lt;p&gt;When each ligand binds an individual receptor, the binding should be independent, regardless of the nature of the ligand. Hence, in theory, &lt;span class=&#34;math inline&#34;&gt;\(n_H = 1\)&lt;/span&gt; and we can assign a narrow prior, say &lt;span class=&#34;math inline&#34;&gt;\(n_H \sim {\sf Normal}(1, 0.1)\)&lt;/span&gt;. This prior puts 95% of the probability between 0.8 and 1.2. If we were very sure, we could go for an even narrower prior.&lt;/p&gt;
&lt;p&gt;In case we encountered a response with cooperative binding, we would just move the prior distribution a bit above 1. For instance, if we were studying hemoglobin, we could put the prior at &lt;span class=&#34;math inline&#34;&gt;\({\sf Normal}(2.5, 0.5)\)&lt;/span&gt; or thereabouts.&lt;/p&gt;
&lt;p&gt;We know one more thing though. The Hill coefficient cannot be less than zero, as that would change the kinetics of the system. With the narrow prior around &lt;span class=&#34;math inline&#34;&gt;\(n_H = 1\)&lt;/span&gt; it is not really an issue, as there is virtually no probability mass below 0, but for kinetics with diminishing returns, an exponential prior or a half-normal distribution may be preferable.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;a-prior-for-the-maximum-tissue-response&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;A prior for the maximum tissue response&lt;/h3&gt;
&lt;p&gt;When discussing the &lt;span class=&#34;math inline&#34;&gt;\(top\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(bottom\)&lt;/span&gt; parameters, it is worth discussing assay technique. Even though the assay is performed &lt;em&gt;in vitro&lt;/em&gt;, the subject, e.g. tissue, receptor, or enzyme, is often a biological construct and thus likely to exhibit batch variation. Furthermore, the raw assay reading carries no particular meaning. Instead, we employ controls to get a normalised response. For instance, we might use a bit of buffer as a negative control and assign the corresponding response to 1 and, at the other end, we might use a known strongly binding ligand as a positive control and assign the corresponding response to 0. The raw readings are then normalised between these two controls to yield the assay response, &lt;span class=&#34;math inline&#34;&gt;\(y_i\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Back to the maximum response. In most contexts, the maximum response is not all that interesting compared to the other parameters. We expect the maximum response to be in the vicinity of the negative control, and if we were doing regular curve fitting, we might just fix the maximum response at 1.&lt;/p&gt;
&lt;p&gt;In terms of probabilities, it means that we have very strong prior knowledge about the maximum response. We could allow it to vary a bit, but I assert that is would not offer much utility.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;a-prior-for-the-minimum-tissue-response&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;A prior for the minimum tissue response&lt;/h3&gt;
&lt;p&gt;The minimum response, &lt;span class=&#34;math inline&#34;&gt;\(bottom\)&lt;/span&gt;, is much more interesting, as it represents the greatest effect a ligand can have on a tissue response. Analogous to the negative control, we set the response of a positive control to 0. However, we cannot necessarily fix the minimum response at this point.&lt;/p&gt;
&lt;p&gt;Imagine an assay where we are testing a chemical compound in the hopes of identifying a new antagonist for the tissue response of interest. If the compound is not a ligand for the receptor, there is no response and &lt;span class=&#34;math inline&#34;&gt;\(bottom = top\)&lt;/span&gt;. On the other hand, if we come across a ligand, then it might elicit a stronger or weaker response than the positive control.&lt;/p&gt;
&lt;p&gt;What does this mean in terms of a prior? It means that screening experiments require a relatively wide prior for the &lt;span class=&#34;math inline&#34;&gt;\(bottom\)&lt;/span&gt; parameter; we only know that it should be less than &lt;span class=&#34;math inline&#34;&gt;\(top\)&lt;/span&gt; and that it is unlikely to be much smaller than 0. However, if we are studying the kinetics of the system and we have a known strong ligand as positive control, we can choose a much narrower prior around 0.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;a-prior-for-potency&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;A prior for potency&lt;/h3&gt;
&lt;p&gt;Deciding on a prior for &lt;span class=&#34;math inline&#34;&gt;\(IC_{50}\)&lt;/span&gt; is difficult for two reasons. If we are screening new compounds, we might have no idea about the potency of the compound or whether it even has potency at all. Secondly, &lt;span class=&#34;math inline&#34;&gt;\(IC_{50}\)&lt;/span&gt; is a concentration and the tissue response depends on the ligand concentration relative to this concentration. In other words, it is the magnitude of the potency that matters.&lt;/p&gt;
&lt;p&gt;The way to handle this is by thinking of a prior for &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50})\)&lt;/span&gt; instead. Units matter, but if we use Molar concentration then &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50}) = -9\)&lt;/span&gt; would correspond to an extremely potent ligand and &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50}) = 0\)&lt;/span&gt; would correspond to extremely low potency.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;a-prior-for-experiment-noise&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;A prior for experiment noise&lt;/h3&gt;
&lt;p&gt;Hopefully, the experiment noise is minimal. Consider &lt;span class=&#34;math inline&#34;&gt;\(\sigma = 0.1\)&lt;/span&gt;. Since we expect most readings to fall in the range &lt;span class=&#34;math inline&#34;&gt;\([0, 1]\)&lt;/span&gt;, this noise level translates to 95% of assay responses being within +-20% of the tissue response. This might be a lot or it might be what is expected from a biological assay, but the point is that, as long as we normalise the assay responses, this parameter should be easy to reason about. For instance, &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt; can never be less than zero, and if it is higher than 0.5, then the assay is more noise than signal.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;example-studies&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Example Studies&lt;/h1&gt;
&lt;p&gt;Let’s move on to some simulated studies&lt;/p&gt;
&lt;div id=&#34;example-study-1---exploring-kinetics&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Example Study 1 - Exploring Kinetics&lt;/h2&gt;
&lt;p&gt;In this study we are imagining a situation where we are trying to learn more about the kinetics of a tissue response. We are investigating a receptor for which we have a known strongly binding antagonist. We suspect that the receptor has multiple binding sites and that ligand binding is not independent. We also do not know the potency, &lt;span class=&#34;math inline&#34;&gt;\(IC_{50}\)&lt;/span&gt;, of the antagonist, but we know that maximum tissue response is observed at &lt;span class=&#34;math inline&#34;&gt;\([A_i] &amp;gt; 10^{-3}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Let’s set some ‘secret’ values for the system and simulate assay readings. Later, we will try to recover these values.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;study_1_params &amp;lt;- list(
  bottom = 0,
  top = 1,
  log_IC50 = -5.6,
  nH = 1.4,
  sigma = 0.05
)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;a-model-for-study-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;A model for study 1&lt;/h3&gt;
&lt;p&gt;Before performing the experiment, i.e. simulating observations, we should take some time to reflect on our domain expertise and translate it into a bespoke probabilistic model for this particular scenario.&lt;/p&gt;
&lt;p&gt;We know that we will measure an assay response, &lt;span class=&#34;math inline&#34;&gt;\(y_i\)&lt;/span&gt;, for a number of ligand concentrations &lt;span class=&#34;math inline&#34;&gt;\([A_i]\)&lt;/span&gt;. We also know that the assay response averages to the tissue response, &lt;span class=&#34;math inline&#34;&gt;\(\mu_i\)&lt;/span&gt;, but that observations are noisy:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[y_i \sim {\sf Normal}(\mu_i, \sigma)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The tissue response is a deterministic function of four kinetic parameters, as described by the Hill equation:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\mu_i = top - \frac{bottom - top}{1 + 10^{(\log_{10}(IC_{50}) - \log_{10}([A_i]))^{n_H}}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The &lt;span class=&#34;math inline&#34;&gt;\(top\)&lt;/span&gt; parameter should, on average, be equal to our negative control, which we fix at 1. Our negative control is just water or buffer, and we have no reason to believe that the maximum tissue response when ligand concentration is infinitely small is any different from the buffer. Thus, our domain expertise tells us to put a very narrow prior on this parameter:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[top \sim {\sf Normal}(1, 0.01)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The &lt;span class=&#34;math inline&#34;&gt;\(bottom\)&lt;/span&gt; parameter should, on average, be equal to our positive control, which we fix at 0. Our positive control is an extreme concentration of the ligand to be sure that it elicits the minimum tissue response. We have no reason to believe that the minimum tissue response when ligand concentration is infinitely large is any different from the extreme concentration. Thus, our domain expertise tells us to put a very narrow prior on this parameter too:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[bottom \sim {\sf Normal}(0, 0.01)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We do not know much about the Hill coefficient, &lt;span class=&#34;math inline&#34;&gt;\(n_H\)&lt;/span&gt;, as we have limited experience with the underlying kinetics. We do, however, know that the Hill coefficient should not be less than 0. While &lt;span class=&#34;math inline&#34;&gt;\(n_H\)&lt;/span&gt; may be more or less than 1, we also know that it is very unlikely that it is orders of magnitude smaller or larger. We can place a wide log-normal prior on this parameter to keep it positive and we can choose distribution parameters such that there is equal probability above and below 1:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[n_H \sim {\sf LogNormal}(0, 1)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We also do not know much about &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50})\)&lt;/span&gt;, but we consider -9 and -3 fairly extreme values, so we can just use a wide normal prior that keeps the parameter mostly in that range:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\log_{10}(IC_{50}) \sim {\sf Normal}(-6, 1.5)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Finally, we should consider how noisy our observations might be. We have little experience with this assay, so we expect a lot of noise. Let’s say that we expect the assay response to be within 20% above or below the tissue response, in most cases. This roughly translates to an expectation of &lt;span class=&#34;math inline&#34;&gt;\(\sigma = 0.1\)&lt;/span&gt;. We also know that &lt;span class=&#34;math inline&#34;&gt;\(\sigma &amp;gt; 0\)&lt;/span&gt;, so we can use an exponential prior with an expectation of 0.1, i.e. a rate of 10:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\sigma \sim {\sf Exp}(10)\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;prior-predictive-check-in-tidyverse&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Prior predictive check in Tidyverse&lt;/h3&gt;
&lt;p&gt;With the model specified, my hands are itching to start fitting. That would be a poor idea, though. Before fitting, we should verify that the model as a whole conforms to our domain knowledge. Even though we have chosen what we think are reasonable priors, it it difficult to get an intuition about how all those priors interact. However, since the model is probabilistic and generative, we can sample predictions from it without fitting anything first. If the distribution of those prior predictions agree with our expectations, then we are good to go.&lt;/p&gt;
&lt;p&gt;For a simple model like this, it is fairly easy to perform such a prior predictive check with Tidyverse and basic R functionality. First we sample parameters from the prior distributions, then we calculate the deterministic variables, and finally draw out the curves.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;n_samples &amp;lt;- 50
# A function to easily sample prior parameters
study_1_priors &amp;lt;- function(n) {
  tibble::tibble(
    top = rnorm(n, 1, 0.01),
    bottom = rnorm(n, 0, 0.01),
    nH = rlnorm(n, 0, 1),
    log_IC50 = rnorm(n, -6, 1.5),
    sigma = rexp(n, 10)
  )
}
# Draw each corresponding assay response
study_1_prior_pred_samples &amp;lt;- study_1_priors(n_samples) %&amp;gt;%
  dplyr::filter(top &amp;gt; bottom) %&amp;gt;% # This is very unlikely to happen though
  dplyr::mutate(
    tissue_response = purrr::pmap(
      list(top, bottom, nH, log_IC50, sigma),
      ~ geom_function(
        fun = assay_response,
        args = list(
          top = ..1,
          bottom = ..2,
          nH = ..3,
          log_IC50 = ..4,
          sigma = ..5
        ),
        colour = colour$blue_dark,
        alpha = 0.5
      )
    )
  )

p &amp;lt;- ggplot() +
  xlim(-9, -3) +
  theme_minimal() +
  labs(x = &amp;quot;Ligand concentration [M]&amp;quot; , y = &amp;quot;Prior assay response&amp;quot;)
Reduce(`+`, study_1_prior_pred_samples$tissue_response, init = p)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/bespoke-biochem-one/index_files/figure-html/prior_pred_check_example_1-1.png&#34; width=&#34;90%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This looks much like the curves we would expect from a real assay. Extreme concentrations have extreme responses and the s-shaped part of the curve is somewhere in between. In some cases, the noise is extreme but that is probably to be expected from an assay where we have little or no experience.&lt;/p&gt;
&lt;p&gt;I initially set the prior for &lt;span class=&#34;math inline&#34;&gt;\(n_H\)&lt;/span&gt; way too wide, resulting in many extreme responses. That does not comply with domain knowledge, so I shrunk the prior.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;building-a-stan-model-for-study-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Building a Stan model for study 1&lt;/h3&gt;
&lt;p&gt;Now we are almost ready to fit the model. To do so, I have implemented it in Stan. There are other excellent introductions to Stan, see the &lt;a href=&#34;https://mc-stan.org/docs/2_28/stan-users-guide/index.html&#34;&gt;Stan User Guide&lt;/a&gt; or some of the references below.&lt;/p&gt;
&lt;p&gt;Here is the Stan model that corresponds to the model described above.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;writeLines(readLines(&amp;quot;hill_equation_study_1.stan&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;data {
  int&amp;lt;lower=0&amp;gt; N; // Number of observations
  vector[N] log_conc; // Tested concentration on log10 scale
  vector[N] y; // Normalised assay responses
}
parameters {
  real bottom;
  real&amp;lt;lower=bottom&amp;gt; top;
  real log_IC50;
  real&amp;lt;lower=0&amp;gt; nH;
  real&amp;lt;lower=0&amp;gt; sigma;
}
model {
  vector[N] mu;
  bottom ~ normal(0, 0.01);
  top ~ normal(1, 0.01);
  log_IC50 ~ normal(-6, 1.5);
  nH ~ lognormal(0, 1);
  sigma ~ exponential(10);
  for ( i in 1:N) {
    mu[i] = top + (bottom - top)/(1 + 10^((log_IC50 - log_conc[i])*nH));
  }
  y ~ normal(mu, sigma);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;fitting-study-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Fitting study 1&lt;/h3&gt;
&lt;p&gt;Now we can simulate some observations and fit the model. To make the simulation realistic, we generate observations in a wide space of ligand concentration, from &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}([A_i]) = -9\)&lt;/span&gt; to &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}([A_i]) = -3\)&lt;/span&gt;. To make it a challenge, we will generate just 6 observations.&lt;/p&gt;
&lt;p&gt;Fitting our bespoke Bayesian model amounts to sampling from the posterior distribution. Here I am drawing 1000 samples per chain from the posterior. This is not a large model, so we could easily sample a lot more if we wanted.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;n_observations &amp;lt;- 6
n_posterior_samples &amp;lt;- 1e3

# Determine the log concentrations at which to simulate
study_1_concentrations &amp;lt;- seq(-9, -3, length.out = n_observations)

# Simulate observations using our &amp;#39;secret&amp;#39; parameters
study_1_observations &amp;lt;- rlang::exec(
  assay_response,
  study_1_concentrations,
  !!!study_1_params
)

# Everything the model needs to know
study_1_data_list &amp;lt;- list(
  N = n_observations,
  log_conc = study_1_concentrations,
  y = study_1_observations
)

# This compiles the model and samples from the posterior
study_1_post &amp;lt;- rstan::stan(
  &amp;quot;hill_equation_study_1.stan&amp;quot;,
  data = study_1_data_list,
  chains = 4,
  iter = n_posterior_samples * 2,
  warmup = n_posterior_samples,
  seed = 4444
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we have samples from the posterior distribution. Let’s put them to work!&lt;/p&gt;
&lt;p&gt;Recall that the underlying research question was the kinetics of the tissue response. So more than the actual tissue response, we are interested in the posterior marginal distributions for the Hill coefficient, &lt;span class=&#34;math inline&#34;&gt;\(n_H\)&lt;/span&gt;, and the potency, &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50})\)&lt;/span&gt;. We can extract samples for the marginal distribution of each of our model parameters.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Extract samples from the posterior distribution
posterior_samples &amp;lt;- rstan::extract(study_1_post) %&amp;gt;% 
  tibble::as_tibble() %&amp;gt;%
  dplyr::select(bottom, top, log_IC50, nH, sigma)

# True parameters of the simulation.
parameter_tibble &amp;lt;- study_1_params %&amp;gt;%
  tibble::as_tibble() %&amp;gt;%
  tidyr::pivot_longer(
    dplyr::everything(),
    names_to = &amp;quot;parameter&amp;quot;,
    values_to = &amp;quot;truth&amp;quot;
  )

# Plot each of the marginal distributions, comparing prior, posterior, and true
#  simulation parameters
posterior_samples %&amp;gt;%
  tidyr::pivot_longer(
    dplyr::everything(),
    names_to = &amp;quot;parameter&amp;quot;,
    values_to = &amp;quot;sample&amp;quot;
  ) %&amp;gt;%
  dplyr::left_join(parameter_tibble, by = &amp;quot;parameter&amp;quot;) %&amp;gt;%
  ggplot() +
  geom_histogram(
    data = tidyr::pivot_longer(
      study_1_priors(nrow(posterior_samples)),
      dplyr::everything(),
      names_to = &amp;quot;parameter&amp;quot;,
      values_to = &amp;quot;sample&amp;quot;
    ),
    mapping = aes(x = sample, fill = &amp;quot;Prior&amp;quot;),
    bins = 50,
    alpha = 0.5
  ) +
  geom_histogram(aes(x = sample, fill = &amp;quot;Posterior&amp;quot;), bins = 50, alpha = 0.5) +
  geom_vline(aes(xintercept = truth, colour = &amp;quot;truth&amp;quot;), alpha = 0.5) +
  facet_wrap(~ parameter, scales = &amp;quot;free&amp;quot;) +
  theme_minimal() +
  scale_colour_manual(values = c(&amp;quot;truth&amp;quot; = colour$orange_light)) +
  scale_fill_manual(values = c(
    &amp;quot;Prior&amp;quot; = colour$azure,
    &amp;quot;Posterior&amp;quot; = colour$blue_dark
  )) +
  labs(
    y = &amp;quot;Posterior sample count&amp;quot;,
    x = &amp;quot;&amp;quot;,
    colour = &amp;quot;&amp;quot;,
    fill = &amp;quot;&amp;quot;,
    title = &amp;quot;Marginal Posterior and Prior Distributions&amp;quot;
  )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/bespoke-biochem-one/index_files/figure-html/posterior_marginals_example_1-1.png&#34; width=&#34;90%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;There are so many exciting things to discuss here. I have opted to plot samples from both the posterior and prior distributions, so we can appreciate how the data worked to update our prior beliefs to posterior distributions.&lt;/p&gt;
&lt;p&gt;The first thing to notice is that the parameters for which we selected very narrow priors, i.e. &lt;span class=&#34;math inline&#34;&gt;\(top\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(bottom\)&lt;/span&gt;, nothing has changed. The data is not enough to overwhelm the strong priors and the posterior is mostly informed by the prior.&lt;/p&gt;
&lt;p&gt;On the other hand, the data has provided enough information to concentrate the probability density to a much narrower interval for the three remaining parameters. The posterior median for &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50})\)&lt;/span&gt; is very close to the truth. &lt;span class=&#34;math inline&#34;&gt;\(nH\)&lt;/span&gt; is a bit more uncertain, but most of the probability is concentrated well above one, which correctly suggests cooperatively binding ligands.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;post_summaries &amp;lt;- rstan::summary(
  study_1_post,
  pars = c(&amp;quot;bottom&amp;quot;, &amp;quot;top&amp;quot;, &amp;quot;log_IC50&amp;quot;, &amp;quot;nH&amp;quot;, &amp;quot;sigma&amp;quot;),
  probs = c(0.055, 0.5, 0.945)
)$summary

tibble::as_tibble(post_summaries) %&amp;gt;% 
  dplyr::select(c(&amp;quot;5.5%&amp;quot;, &amp;quot;50%&amp;quot;, &amp;quot;94.5%&amp;quot;)) %&amp;gt;%
  dplyr::mutate(parameter = rownames(post_summaries), .before = 1) %&amp;gt;%
  knitr::kable()&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;parameter&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5.5%&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;50%&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;94.5%&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;bottom&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.0170975&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.0010557&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0144481&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;top&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9861742&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0016366&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0170142&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;log_IC50&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-5.7516723&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-5.5360470&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-5.4050335&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;nH&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9012444&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.6121050&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4.1663929&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;sigma&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0434627&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0712316&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.1351734&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;At this point, we can draw a conclusion for our experiment: Given our model assumptions, data strongly suggests cooperatively binding kinetics with a 89% compatibility interval for &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50})\)&lt;/span&gt; at about &lt;span class=&#34;math inline&#34;&gt;\([-5.75, -5.41]\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;To improve the result, we could run another experiment using this much narrower range for &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50})\)&lt;/span&gt; as a prior and for determining ligand concentrations to test, as that interval is likely to contain the s-shaped part of the Hill curve.&lt;/p&gt;
&lt;p&gt;Speaking of the Hill curve, let’s see what our posterior predictions look like for the tissue response as a function of log ligand concentration.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;study_1_post_pred &amp;lt;- posterior_samples %&amp;gt;%
  tidyr::expand_grid(log_conc = seq(-3, -9, length.out = 50)) %&amp;gt;% 
  dplyr::mutate(tissue_response = purrr::pmap_dbl(
    list(log_conc, bottom, top, log_IC50, nH),
    hill_function
  )) %&amp;gt;%
  dplyr::group_by(log_conc) %&amp;gt;%
  dplyr::summarise(
    response_mean = mean(tissue_response),
    response_upper = quantile(tissue_response, probs = 0.945),
    response_lower = quantile(tissue_response, probs = 0.055)
  ) %&amp;gt;%
  ggplot() +
  geom_ribbon(
    aes(
      x = log_conc,
      ymin = response_lower,
      ymax = response_upper,
      fill = &amp;quot;89% interval&amp;quot;
    ),
    alpha = 0.5
  ) +
  geom_line(aes(x = log_conc, y = response_mean, colour = &amp;quot;Posterior mean&amp;quot;)) +
  geom_point(
    data = tibble::tibble(
      log_conc = study_1_concentrations,
      observations = study_1_observations
    ),
    aes(x = log_conc, y = observations, colour = &amp;quot;Observations&amp;quot;)
  ) +
  geom_function(
    fun = hill_function,
    args = study_1_params[-5],
    mapping = aes(colour = &amp;quot;True tissue response&amp;quot;)
  ) +
  labs(
    y = &amp;quot;Tissue response&amp;quot;,
    x = &amp;quot;Log ligand concentration [M]&amp;quot;,
    colour = &amp;quot;&amp;quot;,
    fill = &amp;quot;&amp;quot;
  ) +
  scale_fill_manual(values = c(&amp;quot;89% interval&amp;quot; = colour$azure)) +
  theme_minimal()
study_1_post_pred +
  scale_colour_manual(values = c(
    &amp;quot;Posterior mean&amp;quot; = colour$blue_dark,
    &amp;quot;Observations&amp;quot; = colour$orange_light,
    &amp;quot;True tissue response&amp;quot; = colour$orange_dark
  ))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/bespoke-biochem-one/index_files/figure-html/posterior_predictive_example_1-1.png&#34; width=&#34;90%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The true tissue response is all contained in the 89% interval for the posterior predicted response, despite noisy observations and despite the fact that 5 out of 6 observations lie outside the s-shaped part of the curve.&lt;/p&gt;
&lt;p&gt;However, it also seems that we got lucky and had an observation very close to the true &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50})\)&lt;/span&gt;. This point quite clearly provides an anchor for the entire model. We might not always be this lucky. In that case, however, the posterior marginal distributions for the kinetic parameters would just be much more informed by the priors, in turn telling us that we should perform more experiments.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;example-study-2---new-drug&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Example Study 2 - New Drug&lt;/h2&gt;
&lt;p&gt;In this study, we imagine that we are developing a new potential drug candidate. As a part of the development process, we have produced a modified version of an endogenous ligand and we are looking to assess its potency, &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50})\)&lt;/span&gt;, and efficacy, which is defined in terms of &lt;span class=&#34;math inline&#34;&gt;\(bottom\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;We are able to approximate the tissue response &lt;em&gt;in vitro&lt;/em&gt;, but it involves complex biochemistry, so noisy measurements are to be expected.&lt;/p&gt;
&lt;p&gt;The tissue response to the endogenous ligand is well characterised, so we know that the ligands bind independently, i.e. &lt;span class=&#34;math inline&#34;&gt;\(n_H = 1\)&lt;/span&gt;, and we know that for the endogenous ligand &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50}) = -7.2\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Let’s set some ‘secret’ values for the system and simulate assay readings. Later, we will try to recover these values.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;study_2_params &amp;lt;- list(
  bottom = 0.2,
  top = 1,
  log_IC50 = -7.6,
  nH = 1,
  sigma = 0.1
)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;a-model-for-study-2&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;A model for study 2&lt;/h3&gt;
&lt;p&gt;We are still assuming the same kinetics for the tissue response as in study 1.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[y_i \sim {\sf Normal}(\mu_i, \sigma)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\mu_i = top - \frac{bottom - top}{1 + 10^{(\log_{10}(IC_{50}) - \log_{10}([A_i]))^{n_H}}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Our assumptions about the &lt;span class=&#34;math inline&#34;&gt;\(top\)&lt;/span&gt; parameter are the same as in study 1.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[top \sim {\sf Normal}(1, 0.01)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In this case, we have produced a variant of the endogenous ligand. The most likely scenario is that our modification causes the ligand to lose efficacy such that the minimum tissue response is somewhere between 0 and 1. However, there is a small chance that our superior design yields a ligand that is more efficacious than the endogenous ligand and thus has a minimum response below 0. Our prior for the &lt;span class=&#34;math inline&#34;&gt;\(bottom\)&lt;/span&gt; parameter should thus be concentrated between 0 and 1 but with some probability below 0. I have opted for a normal prior.&lt;/p&gt;
&lt;p&gt;Note that this prior puts some probability in the scenario where the &lt;span class=&#34;math inline&#34;&gt;\(bottom\)&lt;/span&gt; parameter is larger than the &lt;span class=&#34;math inline&#34;&gt;\(top\)&lt;/span&gt; parameter. This is not consistent with our domain knowledge and it is a challenge that we will handle in a moment.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[bottom \sim {\sf Normal}(0.25, 0.25)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Changing the ligand will not change the receptor, so it is extremely unlikely that the Hill coefficient changes.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[n_H \sim {\sf Normal}(1, 0.01)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The modified ligand is likely to lose potency, i.e. have a higher &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50})\)&lt;/span&gt;, compared to the endogenous ligand which has &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50}) = -7.2\)&lt;/span&gt;, but we might get lucky and see an increase. This is not much to go on, but it should still allow us to use a narrower prior than in study 1.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\log_{10}(IC_{50}) \sim {\sf Normal}(-6, 0.7)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Noise is expected to be quite severe.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\sigma \sim {\sf Exp}(10)\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;prior-predictive-check-with-stan&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Prior predictive check with Stan&lt;/h3&gt;
&lt;p&gt;As in the previous study, we should check that the prior predictive distribution conforms to expectations as given by our domain expertise.&lt;/p&gt;
&lt;p&gt;This time I have opted to utilise Stan to sample from the priors. It is a bit of extra work, but it scales well for larger and more complex models.&lt;/p&gt;
&lt;p&gt;One challenge we have, is the constraint that &lt;span class=&#34;math inline&#34;&gt;\(top \ge bottom\)&lt;/span&gt;. A way to handle this could be to discard any samples that violates the constraint and replace them with new samples until the desired number of samples are obtained. I would like something a bit more elegant.&lt;/p&gt;
&lt;p&gt;In Stan, constraints can be set on parameters and, during Monte Carlo sampling from the posterior, those constraints are enforced. However, when we want to use random number generators to sample from the prior distributions, we have to enforce it ourselves. I have implemented a small Stan program to sample from the priors in study 2:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;writeLines(readLines(&amp;quot;hill_equation_study_2_prior.stan&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;functions {
  // A lower-bounded normal distribution random number generator
  real normal_lower_rng(real mu, real sigma, real lower_bound) {
    // Locate the lower bound
    real p_lower_bound = normal_cdf(lower_bound, mu, sigma);
    // Uniformly sample probabilities in the bounded range
    real u = uniform_rng(p_lower_bound, 1);
    // Transform back to a normal distribution
    real y = mu + sigma * inv_Phi(u);
    return y;
  }
  // An upper-bounded normal distribution random number generator
  real normal_upper_rng(real mu, real sigma, real upper_bound) {
    // Locate the upper bound
    real p_upper_bound = normal_cdf(upper_bound, mu, sigma);
    // Uniformly sample probabilities in the bounded range
    real u = uniform_rng(0, p_upper_bound);
    // Transform back to a normal distribution
    real y = mu + sigma * inv_Phi(u);
    return y;
  }
}
data {
  int&amp;lt;lower=0&amp;gt; N; // Number of samples
  vector[N] log_conc; // Tested concentration on log10 scale
}
generated quantities{
  real&amp;lt;lower = 0&amp;gt; nH = normal_lower_rng(1, 0.01, 0);
  real top = normal_rng(1, 0.01);
  real bottom = normal_upper_rng(0.25, 0.25, top);
  real log_IC50 = normal_rng(-6, 0.7);
  real sigma = exponential_rng(10);
  vector[N] mu;
  vector[N] y;
  for ( i in 1:N) {
    mu[i] = top + (bottom - top)/(1 + 10^((log_IC50 - log_conc[i])*nH));
    y[i] = normal_rng(mu[i], sigma);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that there is no &lt;code&gt;model&lt;/code&gt; block in the code. This program should not run a Monte Carlo simulation. Rather, it should just pull samples from the prior distributions. This can be accomplished with Stan’s Fixed Parameter mode.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;n_prior_samples &amp;lt;- 50
log_conc &amp;lt;- seq(-9, -3, length.out = n_prior_samples)

prior &amp;lt;- rstan::stan(
  &amp;quot;hill_equation_study_2_prior.stan&amp;quot;,
  data = list(N = n_prior_samples, log_conc = log_conc),
  algorithm = &amp;quot;Fixed_param&amp;quot;,
  chains = 1,
  iter = 100,
  warmup = 0,
  seed = 4444
)

samples &amp;lt;- rstan::extract(prior)

sample_readings &amp;lt;- lapply(1:100, function(i) {
  tibble::tibble(
  y = samples$y[i,],
  x = log_conc
) %&amp;gt;% 
  geom_line(mapping = aes(x, y), colour = colour$blue_dark, alpha = 0.5)
})
p &amp;lt;- ggplot() + 
  theme_minimal() +
  labs(x = &amp;quot;Ligand concentration [M]&amp;quot; , y = &amp;quot;Prior assay response&amp;quot;)
Reduce(`+`, sample_readings, init = p)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/bespoke-biochem-one/index_files/figure-html/prior_2_stan-1.png&#34; width=&#34;90%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We expect most potential curves to reach 50% of their minimum response well above -7.2, corresponding to lost potency. There is, however, still a small chance of increased potency, i.e. a value smaller than -7.2. Likewise for the minimum response, we find it most likely that a modification will cause the minimum response to be somewhere between 0 and 1, yet there is a chance that the minimum response is less than zero.&lt;/p&gt;
&lt;p&gt;All in all, these seem like suitable priors, but we also note that the amount of noise could severely impact conclusions.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;building-a-stan-model-for-study-2&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Building a Stan model for study 2&lt;/h3&gt;
&lt;p&gt;Here is the Stan model that corresponds to the model described above. Note that we do not need to specify our own distribution functions to satisfy constraints. When running the simulation, Stan keeps track of constraints and makes sure that they are satisfied.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;writeLines(readLines(&amp;quot;hill_equation_study_2_post.stan&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;data {
  int&amp;lt;lower=0&amp;gt; N;
  vector[N] log_conc;
  vector[N] y;
}
parameters {
  real bottom;
  real&amp;lt;lower=bottom&amp;gt; top;
  real log_IC50;
  real&amp;lt;lower=0&amp;gt; nH;
  real&amp;lt;lower=0&amp;gt; sigma;
}
model {
  vector[N] mu;
  bottom ~ normal(0.25, 0.25);
  top ~ normal(1, 0.01);
  log_IC50 ~ normal(-6, 0.7);
  nH ~ normal(1, 0.01);
  sigma ~ exponential(10);
  for ( i in 1:N) {
    mu[i] = top + (bottom - top)/(1 + 10^((log_IC50 - log_conc[i])*nH));
  }
  y ~ normal(mu, sigma);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;fitting-study-2&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Fitting study 2&lt;/h3&gt;
&lt;p&gt;Now we can simulate some observations and fit the model. As we do not expect our modified ligand to stray too far from the curve of the endogenous ligand, we generate observations in a narrow space of ligand concentration, from &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}([A_i]) = -7.5\)&lt;/span&gt; to &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}([A_i]) = -4.5\)&lt;/span&gt;. To make it a challenge, we will generate just 6 observations.&lt;/p&gt;
&lt;p&gt;As for study 1, I am drawing 1000 samples per chain from the posterior.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;n_observations &amp;lt;- 6
n_posterior_samples &amp;lt;- 1e3

# Determine the log concentrations at which to simulate
study_2_concentrations &amp;lt;- seq(-7.5, -4.5, length.out = n_observations)

# Simulate observations using our &amp;#39;secret&amp;#39; parameters
study_2_observations &amp;lt;- rlang::exec(
  assay_response,
  study_2_concentrations,
  !!!study_2_params
)

# Everything the model needs to know
data_list &amp;lt;- list(
  N = n_observations,
  log_conc = study_2_concentrations,
  y = study_2_observations
)

# This compiles the model and samples from the posterior
study_2_post &amp;lt;- rstan::stan(
  &amp;quot;hill_equation_study_2_post.stan&amp;quot;,
  data = data_list,
  chains = 4,
  iter = n_posterior_samples * 2,
  warmup = n_posterior_samples,
  seed = 4444
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The underlying research question for this study was primarily concerned with the &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50})\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(bottom\)&lt;/span&gt; parameters. So more than the actual tissue response, we are interested in the marginal posterior distributions for these two parameters. Let’s start by summarising the marginal posterior distributions.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;study_2_priors &amp;lt;- function(n) {
  tibble::tibble(
    top = rnorm(n, 1, 0.01),
    bottom = rnorm(n, 0.25, 0.25),
    nH = rnorm(n, 1, 0.01),
    log_IC50 = rnorm(n, -6, 0.7),
    sigma = rexp(n, 10)
  )
}

# Extract samples from the posterior distribution
posterior_samples &amp;lt;- rstan::extract(study_2_post) %&amp;gt;% 
  tibble::as_tibble() %&amp;gt;%
  dplyr::select(bottom, top, log_IC50, nH, sigma)

# True parameters of the simulation.
parameter_tibble &amp;lt;- study_2_params %&amp;gt;%
  tibble::as_tibble() %&amp;gt;%
  tidyr::pivot_longer(
    dplyr::everything(),
    names_to = &amp;quot;parameter&amp;quot;,
    values_to = &amp;quot;truth&amp;quot;
  )

# Plot each of the marginal distributions, comparing prior, posterior, and true
#  simulation parameters
posterior_samples %&amp;gt;%
  tidyr::pivot_longer(
    dplyr::everything(),
    names_to = &amp;quot;parameter&amp;quot;,
    values_to = &amp;quot;sample&amp;quot;
  ) %&amp;gt;%
  dplyr::left_join(parameter_tibble, by = &amp;quot;parameter&amp;quot;) %&amp;gt;%
  ggplot() +
  geom_histogram(
    data = tidyr::pivot_longer(
      study_2_priors(nrow(posterior_samples)),
      dplyr::everything(),
      names_to = &amp;quot;parameter&amp;quot;,
      values_to = &amp;quot;sample&amp;quot;
    ),
    mapping = aes(x = sample, fill = &amp;quot;Prior&amp;quot;),
    bins = 50,
    alpha = 0.5
  ) +
  geom_histogram(aes(x = sample, fill = &amp;quot;Posterior&amp;quot;), bins = 50, alpha = 0.5) +
  geom_vline(aes(xintercept = truth, colour = &amp;quot;truth&amp;quot;), alpha = 0.5) +
  facet_wrap(~ parameter, scales = &amp;quot;free&amp;quot;) +
  theme_minimal() +
  scale_colour_manual(values = c(&amp;quot;truth&amp;quot; = colour$orange_light)) +
  scale_fill_manual(
    values = c(&amp;quot;Prior&amp;quot; = colour$azure, &amp;quot;Posterior&amp;quot; = colour$blue_dark)
  ) +
  labs(
    y = &amp;quot;Posterior sample count&amp;quot;,
    x = &amp;quot;&amp;quot;,
    colour = &amp;quot;&amp;quot;,
    fill = &amp;quot;&amp;quot;,
    title = &amp;quot;Marginal Posterior and Prior Distributions&amp;quot;
  )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/bespoke-biochem-one/index_files/figure-html/posterior_marginals_study_2-1.png&#34; width=&#34;90%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The first thing to notice here is that the posterior probability mass is more concentrated than the prior. However, the marginal posterior distributions for &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50})\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(bottom\)&lt;/span&gt; are still relatively wide. Recall that a difference of one in &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50})\)&lt;/span&gt; is an order of magnitude in terms of concentration. Small changes in potency matter a lot if we have to manufacture the compound at one point. So our data did not tell us much about the precise potency and efficacy of this modified ligand.&lt;/p&gt;
&lt;p&gt;On the other hand, the posterior probability mass is mostly at &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50}) &amp;lt; -7.2\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(bottom &amp;gt; 0\)&lt;/span&gt;, i.e. we are quite certain that our modified ligand has higher potency than the endogenous ligand but elicits a smaller response. With well defined priors and a small amount of data, we have a perfectly good screening experiment.&lt;/p&gt;
&lt;p&gt;If we were interested in gaining a better understanding of the modified ligand, we could perform more experiments and get those posterior probability masses even more concentrated. We also see that the true noise of the assay is quite high; reducing it might help to better learn the underlying tissue response.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;post_summaries &amp;lt;- rstan::summary(
  study_2_post,
  pars = c(&amp;quot;bottom&amp;quot;, &amp;quot;top&amp;quot;, &amp;quot;log_IC50&amp;quot;, &amp;quot;nH&amp;quot;, &amp;quot;sigma&amp;quot;),
  probs = c(0.055, 0.5, 0.945)
)$summary

tibble::as_tibble(post_summaries) %&amp;gt;% 
  dplyr::select(c(&amp;quot;5.5%&amp;quot;, &amp;quot;50%&amp;quot;, &amp;quot;94.5%&amp;quot;)) %&amp;gt;%
  dplyr::mutate(parameter = rownames(post_summaries), .before = 1) %&amp;gt;%
  knitr::kable()&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;parameter&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5.5%&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;50%&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;94.5%&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;bottom&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0848792&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.1544085&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.2183073&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;top&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9831631&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9995818&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0156166&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;log_IC50&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-7.7146376&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-7.4971292&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-7.2296555&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;nH&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9842731&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9999304&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0161020&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;sigma&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0405449&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0680069&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.1388871&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;At this point, we can draw a conclusion for our experiment: Given our model assumptions, data strongly suggests that the modified ligand has higher potency than the endogenous ligand with a 89% credibility interval for &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50})\)&lt;/span&gt; at about &lt;span class=&#34;math inline&#34;&gt;\([-8.08, -7.22]\)&lt;/span&gt;. We also conclude that the modified ligand has less efficacy than the endogenous ligand with a 89% credibility interval for &lt;span class=&#34;math inline&#34;&gt;\(bottom\)&lt;/span&gt; at about &lt;span class=&#34;math inline&#34;&gt;\([0.12, 0.30]\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Before accepting the conclusion, it is a good idea to look at the posterior predictions and compare them to the data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;posterior_samples %&amp;gt;%
  tidyr::expand_grid(log_conc = seq(-3, -9, length.out = 50)) %&amp;gt;% 
  dplyr::mutate(tissue_response = purrr::pmap_dbl(
    list(log_conc, bottom, top, log_IC50, nH),
    hill_function
  )) %&amp;gt;%
  dplyr::group_by(log_conc) %&amp;gt;%
  dplyr::summarise(
    response_mean = mean(tissue_response),
    response_upper = quantile(tissue_response, probs = 0.945),
    response_lower = quantile(tissue_response, probs = 0.055)
  ) %&amp;gt;%
  ggplot() +
  geom_ribbon(
    aes(
      x = log_conc,
      ymin = response_lower,
      ymax = response_upper,
      fill = &amp;quot;89% interval&amp;quot;
    ),
    alpha = 0.5
  ) +
  geom_line(aes(x = log_conc, y = response_mean, colour = &amp;quot;Posterior mean&amp;quot;)) +
  geom_point(
    data = tibble::tibble(
      log_conc = study_2_concentrations,
      observations = study_2_observations
    ),
    aes(x = log_conc, y = observations, colour = &amp;quot;Observations&amp;quot;)
  ) +
  geom_function(
    fun = hill_function,
    args = study_2_params[-5],
    mapping = aes(colour = &amp;quot;True tissue response&amp;quot;)
  ) +
  scale_colour_manual(values = c(
    &amp;quot;Posterior mean&amp;quot; = colour$blue_dark,
    &amp;quot;Observations&amp;quot; = colour$orange_light,
    &amp;quot;True tissue response&amp;quot; = colour$orange_dark
  )) +
  labs(
    y = &amp;quot;Tissue response&amp;quot;,
    x = &amp;quot;Log ligand concentration [M]&amp;quot;,
    colour = &amp;quot;&amp;quot;,
    fill = &amp;quot;&amp;quot;
  ) +
  scale_fill_manual(values = c(&amp;quot;89% interval&amp;quot; = colour$azure)) +
  theme_minimal()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/bespoke-biochem-one/index_files/figure-html/posterior_predictive_study_2-1.png&#34; width=&#34;90%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The true tissue response is all contained in the 89% interval for the posterior predicted response, despite noisy observations and despite the fact that 4 out of 6 observations lie outside the s-shaped part of the curve.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;assessing-posterior-quality&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Assessing posterior quality&lt;/h2&gt;
&lt;p&gt;During the two studies, I avoided a rather important subject, namely assessing the quality of our posterior estimate. The algorithm that explores and samples from the posterior, Hamiltonian Monte Carlo (HMC), is as much a part of the Bayesian model as priors and as such should enjoy the same deliberate consideration.&lt;/p&gt;
&lt;p&gt;We have observed that the posterior predictive distribution yields reasonable predictions, which gives us a lot of confidence in the model as a whole. In these studies, we could also compare the predictions to the true underlying parameters of the simulations, so we know that the model is at least somewhat right.&lt;/p&gt;
&lt;p&gt;All is not perfectly well, however. In study one, Stan complains that during the HMC run there were divergent transitions:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rstan::check_divergences(study_1_post)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;5 of 4000 iterations ended with a divergence (0.125%).
Try increasing &amp;#39;adapt_delta&amp;#39; to remove the divergences.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://mc-stan.org/misc/warnings.html#runtime-warnings&#34;&gt;Stan is noisy&lt;/a&gt; and will complain when something seems wrong in the HMC sampler.&lt;/p&gt;
&lt;p&gt;In this case, it is divergent transitions which usually happens when an iteration ends up in a part of parameter space where the probabilities have large gradients.&lt;/p&gt;
&lt;p&gt;Increasing &lt;code&gt;adapt_delta&lt;/code&gt; as suggested by Stan will help avoid the divergent transitions, but why were they there in the first place? Let’s look at some diagnostic parameters for the posterior in the first study:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;post_summaries &amp;lt;- rstan::summary(
  study_1_post,
  pars = c(&amp;quot;bottom&amp;quot;, &amp;quot;top&amp;quot;, &amp;quot;log_IC50&amp;quot;, &amp;quot;nH&amp;quot;, &amp;quot;sigma&amp;quot;),
  probs = c(0.055, 0.5, 0.945)
)$summary

tibble::as_tibble(post_summaries) %&amp;gt;% 
  dplyr::select(c(&amp;quot;n_eff&amp;quot;, &amp;quot;Rhat&amp;quot;)) %&amp;gt;%
  dplyr::mutate(parameter = rownames(post_summaries), .before = 1) %&amp;gt;%
  knitr::kable()&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;parameter&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;n_eff&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Rhat&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;bottom&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1610.7382&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.002482&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;top&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3738.8936&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.000015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;log_IC50&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1401.6208&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.002600&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;nH&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;523.3805&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.012667&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;sigma&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1414.4814&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.000310&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;n_eff&lt;/code&gt; is an estimate of the number of independent samples from the posterior. &lt;code&gt;Rhat&lt;/code&gt; is a measure of convergence. Values &lt;span class=&#34;math inline&#34;&gt;\(\hat{R} &amp;gt; 1.01\)&lt;/span&gt; indicate that convergence has not entirely been reached.&lt;/p&gt;
&lt;p&gt;According to the diagnostics, the marginal posterior for &lt;span class=&#34;math inline&#34;&gt;\(n_H\)&lt;/span&gt; has been challenging to estimate. This is not altogether surprising, considering that we only have one good point on the s-shaped part of the curve. There are many combinations of &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50})\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(n_H\)&lt;/span&gt; that would pass though the point equally well and some of them have extreme probability gradients.&lt;/p&gt;
&lt;p&gt;So why does increasing &lt;code&gt;adapt_delta&lt;/code&gt; work? Intuitively, it causes Stan to pick a smaller step size for the HMC sampler. This reduces the chance that the sample ends up in a far off part of parameter space where gradients are extreme. The trade-off is that the posterior might be less efficiently sampled, so for larger models, one might have to do more samples to fully explore the posterior.&lt;/p&gt;
&lt;p&gt;Let’s try running study one with an increased &lt;code&gt;adapt_delta&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;study_1_post_improved &amp;lt;- rstan::stan(
  &amp;quot;hill_equation_study_1.stan&amp;quot;,
  data = study_1_data_list,
  chains = 4,
  iter = n_posterior_samples * 2,
  warmup = n_posterior_samples,
  seed = 4444,
  control = list(adapt_delta = 0.95)
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That should improve the situation.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rstan::check_divergences(study_1_post_improved)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0 of 4000 iterations ended with a divergence.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Indeed it did!. Let’s also have a look at the diagnostics.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;post_summaries &amp;lt;- rstan::summary(
  study_1_post_improved,
  pars = c(&amp;quot;bottom&amp;quot;, &amp;quot;top&amp;quot;, &amp;quot;log_IC50&amp;quot;, &amp;quot;nH&amp;quot;, &amp;quot;sigma&amp;quot;),
  probs = c(0.055, 0.5, 0.945)
)$summary

tibble::as_tibble(post_summaries) %&amp;gt;% 
  dplyr::select(c(&amp;quot;n_eff&amp;quot;, &amp;quot;Rhat&amp;quot;)) %&amp;gt;%
  dplyr::mutate(parameter = rownames(post_summaries), .before = 1) %&amp;gt;%
  knitr::kable()&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;parameter&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;n_eff&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Rhat&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;bottom&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2103.743&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9995628&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;top&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3942.552&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0001219&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;log_IC50&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1152.528&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0010730&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;nH&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1380.143&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0016422&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;sigma&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1375.529&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0041702&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The numbers have improved and we have more faith in the posterior samples. Remember though that having good diagnostics alone does not imply a good model. The diagnostic check should be combined with prior and posterior predictive checks to ensure that the model is reasonable.&lt;/p&gt;
&lt;p&gt;There is so much more to discuss about diagnosing HMC - we have barely scratched the surface here. &lt;code&gt;?rstan::check_hmc_diagnostics&lt;/code&gt; is a great place to start, if you want to learn more.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;comparing-to-another-fitting-method&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Comparing to another fitting method&lt;/h2&gt;
&lt;p&gt;Before wrapping up, I’d like to return to my initial goal, which was to squeeze more information out of the data I get from biochemical assays.&lt;/p&gt;
&lt;p&gt;At this point, all we have done is fit a model to two experiments of six data points each and, despite the assistance from Stan, it has taken more code and more computation than a ‘classic’ fit would have. So was it worth it? Let’s compare.&lt;/p&gt;
&lt;p&gt;Here I am fitting the data from study one using non-linear least squares. To make it fair, I have put in as much information as the optimisation algorithm allows: the initial guess is at the median of the priors we set for study one and the parameters are roughly constrained to the 95% prior interval.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mod &amp;lt;- nls(
  y ~ top + (bottom - top)/(1 + 10^((log_IC50 - log_conc)*nH)),
  data = study_1_data_list,
  algorithm = &amp;quot;port&amp;quot;,
  start = list(bottom = 0, top = 1, log_IC50 = -6, nH = 1),
  lower = list(bottom = -0.02, top = 0.98, log_IC50 = -9, nH = 0),
  upper = list(bottom = 0.02, top = 1.02, log_IC50 = -3, nH = 100)
)

study_1_post_pred +
  geom_function(
    fun = hill_function,
    args = mod$m$getPars(),
    mapping = aes(colour = &amp;quot;NLS fit&amp;quot;)
  ) +
  scale_colour_manual(values = c(
    &amp;quot;Posterior mean&amp;quot; = colour$blue_dark,
    &amp;quot;Observations&amp;quot; = colour$orange_light,
    &amp;quot;True tissue response&amp;quot; = colour$orange_dark,
    &amp;quot;NLS fit&amp;quot; = &amp;quot;black&amp;quot;
  ))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/bespoke-biochem-one/index_files/figure-html/posterior_predictive_study_1_improved-1.png&#34; width=&#34;90%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The NLS fit is obviously close to the true tissue response and it took much less code and time to fit. Compared to our Bayesian model, the NLS fit is not bad. In fact, it will be useful in many cases, but there are a few notable differences.&lt;/p&gt;
&lt;p&gt;With the Bayesian model, we get an estimate of the amount of noise in the experiment, in addition to the parameters of the Hill equation. Such an estimate can be very useful for understanding and continuous improvement of the biochemical assays.&lt;/p&gt;
&lt;p&gt;With the Bayesian model, we also get marginal posterior distributions. With a regular fit, we only get a point estimate for each parameter and any uncertainty is lost. We do not always need anything but a point estimate to answer our hypotheses, but the marginal posterior distributions can be useful in future experimental design and as priors for the next experiment.&lt;/p&gt;
&lt;p&gt;Finally there is an added robustness. Biological data has all sorts of weird behaviour. In a situation where the data points are all over the place, due to some unknown external factor, the resulting Bayesian model would show little or no change from the prior model, whereas the NLS model would fail altogether. So with a Bayesian model, we can rely on probabilities to tell us when an experiment is an outlier.&lt;/p&gt;
&lt;p&gt;At the end of the day, the chosen method depends on the downstream application of the parameters and the hypotheses that we are trying to answer with the data. For now, I am keeping both in my toolbox, but I am seeing increased usefulness for the Bayesian approach, especially in screening experiments.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;next-steps&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Next Steps&lt;/h1&gt;
&lt;p&gt;In the preceding two study examples, we spent a lot of time fuzzing over just a few data points. In real applications, however, data is often more abundant and more diverse. In particular, I am thinking of screening experiments. In screening experiments, one might test a large number of potential ligands at once, meaning that there is more data but also more behaviour to be captured.&lt;/p&gt;
&lt;p&gt;In my next study, I will be discussing development of a bespoke Bayesian model for high-throughput biochemical screening assays. Stay tuned!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;references&#34; class=&#34;section level1 unnumbered&#34;&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;div id=&#34;refs&#34; class=&#34;references csl-bib-body&#34;&gt;
&lt;div id=&#34;ref-Neubig597&#34; class=&#34;csl-entry&#34;&gt;
&lt;div class=&#34;csl-left-margin&#34;&gt;[1] &lt;/div&gt;&lt;div class=&#34;csl-right-inline&#34;&gt;&lt;span class=&#34;smallcaps&#34;&gt;Neubig&lt;/span&gt;, R. R., &lt;span class=&#34;smallcaps&#34;&gt;Spedding&lt;/span&gt;, M., &lt;span class=&#34;smallcaps&#34;&gt;Kenakin&lt;/span&gt;, T. and &lt;span class=&#34;smallcaps&#34;&gt;Christopoulos&lt;/span&gt;, A. (2003). International union of pharmacology committee on receptor nomenclature and drug classification. XXXVIII. Update on terms and symbols in quantitative pharmacology. &lt;em&gt;Pharmacological Reviews&lt;/em&gt; &lt;strong&gt;55&lt;/strong&gt; 597–606 Available at &lt;a href=&#34;https://pharmrev.aspetjournals.org/content/55/4/597&#34;&gt;https://pharmrev.aspetjournals.org/content/55/4/597&lt;/a&gt;.&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-McElreath:2016&#34; class=&#34;csl-entry&#34;&gt;
&lt;div class=&#34;csl-left-margin&#34;&gt;[2] &lt;/div&gt;&lt;div class=&#34;csl-right-inline&#34;&gt;&lt;span class=&#34;smallcaps&#34;&gt;McElreath&lt;/span&gt;, R. (2020). &lt;em&gt;Statistical rethinking: A bayesian course with examples in r and stan&lt;/em&gt;. CRC Press.&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-Betancourt:2019&#34; class=&#34;csl-entry&#34;&gt;
&lt;div class=&#34;csl-left-margin&#34;&gt;[3] &lt;/div&gt;&lt;div class=&#34;csl-right-inline&#34;&gt;&lt;span class=&#34;smallcaps&#34;&gt;Betancourt&lt;/span&gt;, M. (2019). Probabilistic modeling and statistical inference. Available at &lt;a href=&#34;https://github.com/betanalpha/knitr_case_studies/tree/master/modeling_and_inference&#34;&gt;https://github.com/betanalpha/knitr_case_studies/tree/master/modeling_and_inference&lt;/a&gt;.&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;license&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;License&lt;/h1&gt;
&lt;p&gt;The content of this project itself is licensed under the &lt;a href=&#34;https://creativecommons.org/licenses/by-sa/4.0/&#34;&gt;Creative Commons Attribution-ShareAlike 4.0 International license&lt;/a&gt;, and the underlying code is licensed under the &lt;a href=&#34;https://github.com/AnHosu/bespoke-bayesian-biochem/blob/main/LICENSE&#34;&gt;GNU General Public License v3.0 license&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Bespoke Bayesian Model for High Throughput Biochemical Assays</title>
      <link>/post/bespoke-biochem-two/</link>
      <pubDate>Fri, 23 Apr 2021 00:00:00 +0000</pubDate>
      <guid>/post/bespoke-biochem-two/</guid>
      <description>
&lt;script src=&#34;../../post/bespoke-biochem-two/index_files/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;I am on a quest to improve the model fitting I do on biochemical assays. For some time, I have had this feeling that I should be able to extract more information from the data gathered in biochemical assays, in particular assays with a high throughput.&lt;/p&gt;
&lt;p&gt;In &lt;a href=&#34;../../project/bespoke-biochem-one&#34;&gt;two previous studies&lt;/a&gt; we built bespoke Bayesian models to fit observations from a biochemical assay with kinetics that could be represented by the Hill equation. In those studies, we fit a single curves one at a time. In this study, we extend the model to capture the additional information available when screening a large number of compounds in parallel.&lt;/p&gt;
&lt;p&gt;We start by setting a seed and some nice colours for plotting.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2)
library(magrittr)

colour &amp;lt;- list(
  orange_dark = &amp;quot;#fb8500&amp;quot;,
  orange_light = &amp;quot;#ffb703&amp;quot;,
  blue_dark = &amp;quot;#023047&amp;quot;,
  azure = &amp;quot;#219ebc&amp;quot;,
  blue_light = &amp;quot;#8ecae6&amp;quot;
)

set.seed(4444)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;high-troughput-biochemical-experiments&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;High Troughput Biochemical Experiments&lt;/h1&gt;
&lt;p&gt;With Bayesian models, we can take advantage of our domain expertise to produce clear answers to our scientific hypotheses and to quantify uncertainty in data and hypotheses. It does, however, require that we are able to represent our expertise as probabilistic models. So before we dive into the Bayesian engine, let’s discuss our biochemistry knowledge and the data we might get from a high throughput experiment.&lt;/p&gt;
&lt;p&gt;We are considering compounds that are potential ligands to receptors and cause a tissue response according to the Hill equation&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\mu_{ij} = top - \frac{bottom_j - top}{1 + 10^{(\log_{10}(IC_{50,j}) - \log_{10}([A_i]))^{n_H}}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Where &lt;span class=&#34;math inline&#34;&gt;\(\mu_{ij}\)&lt;/span&gt; is the tissue response of the &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;’th compound at concentration &lt;span class=&#34;math inline&#34;&gt;\([A_i]\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;The equation looks slightly different from the previous studies because we now have multiple compounds in a screening study. The equation also encodes a few assumptions about such an assay. First of all, we are assuming that the tissue response in the absence of ligand, &lt;span class=&#34;math inline&#34;&gt;\(top\)&lt;/span&gt;, is the same for all tested compounds. Similarly, we are assuming that the kinetics of the tissue response, as represented by the Hill number, &lt;span class=&#34;math inline&#34;&gt;\(n_H\)&lt;/span&gt;, stays the same for all compounds. For the maximum tissue response, &lt;span class=&#34;math inline&#34;&gt;\(bottom_j\)&lt;/span&gt;, and the concentration at half response, &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50,j})\)&lt;/span&gt;, however, we are assuming that each compound has its own parameter.&lt;/p&gt;
&lt;p&gt;These assumptions might not hold true for every experiment, but if we imagine that we are screening compounds for a good drug candidate and we are looking at the same tissue response for each of them, these assumptions should hold.&lt;/p&gt;
&lt;p&gt;As in previous studies, I opt for synthetic data. This has two advantages; we are forced to consider the underlying process that generates our experiment data and, after we have applied a model, we can compare the output to our known truth. We can code the first part of the generative process with a simple function&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;hill_function &amp;lt;- function(log_conc, bottom, top, log_IC50, nH) {
  top + (bottom - top)/(1 + 10^((log_IC50 - log_conc)*nH))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, our observations are not perfect and will be subject to some noise. For this study, we are going to assume that all observations were made in the same batch, under the same conditions, and at the same time such that they have identically distributed noise. Specifically, we will give the observations some Gaussian noise.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;assay_response &amp;lt;- function(log_conc, bottom, top, log_IC50, nH, sigma) {
  noise &amp;lt;- rnorm(length(log_conc), 0, sigma)
  hill_function(log_conc, bottom, top, log_IC50, nH) + noise
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next we should consider what type of screening we are doing. There are a couple of different options. We could screen a lot of random compounds for activity. While this is a common scenario, it is not too interesting to model, as we expect that the vast majority of tested compounds will have no activity. In this study, as in the previous, we instead imagine the case where we produce a large number of variations on an endogenous ligand, in the hopes that we stumble upon something with more desirable properties like higher potency.&lt;/p&gt;
&lt;p&gt;So we produce 100 modifications to an endogenous ligand which has known parameters &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50}) = -7.2\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(bottom = 0\)&lt;/span&gt;. We expect that the modifications might cause us to lose potency, i.e. increase &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50})\)&lt;/span&gt;, and efficacy, i.e. increase &lt;span class=&#34;math inline&#34;&gt;\(bottom\)&lt;/span&gt;, most of the time. To add a little extra challenge, I am adding compounds that have extremely low &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50})\)&lt;/span&gt; corresponding to the case where our modification almost or completely removes potency.&lt;/p&gt;
&lt;p&gt;With this, we have the final part of the generative model:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;n_compounds &amp;lt;- 100

true_parameters &amp;lt;- tibble::tibble(
  compound = seq(1, n_compounds),
  bottom = 1 - rlnorm(n_compounds, -0.25, 0.125),
  log_IC50 = rnorm(n_compounds, -5, 1.5) + rexp(n_compounds, 3),
  top = 1.02,
  nH = 0.99,
  sigma = 0.15
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the generative model in place, we can draw a few of the true curves that we will sample from and estimate in our hypothetical screening experiment.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;true_curves &amp;lt;- purrr::pmap(
  true_parameters,
  ~ geom_function(
    fun = hill_function,
    args = list(
      top = ..4,
      bottom = ..2,
      nH = ..5,
      log_IC50 = ..3
    ),
    colour = colour$blue_dark,
    alpha = 0.5
  )
)

p &amp;lt;- ggplot() +
  xlim(-9, -1) +
  theme_minimal() +
  labs(
    x = &amp;quot;Ligand concentration [M]&amp;quot;,
    y = &amp;quot;True tissue response&amp;quot;,
    title = &amp;quot;Sample True Tissue Responses&amp;quot;
  )

Reduce(`+`, true_curves[1:10], init = p)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/bespoke-biochem-two/index_files/figure-html/generative_model-1.png&#34; width=&#34;90%&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;bespoke-bayesian-model&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Bespoke Bayesian Model&lt;/h1&gt;
&lt;p&gt;Now that we understand the generative process and we have some data, we can start considering a Bayesian model. We need to specify two things; a set of relations that describe the generative process and priors for any parameters. If this seems similar to what we just did in the previous section, it is because it is. The Baysian model should reflect the process that generated the data. So let’s get started.&lt;/p&gt;
&lt;div id=&#34;likelihood-model&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Likelihood Model&lt;/h2&gt;
&lt;p&gt;In our screening assay, we will consider &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; compounds &lt;span class=&#34;math inline&#34;&gt;\(j = 1, ..., M\)&lt;/span&gt;. For each compound, we measure an assay response, &lt;span class=&#34;math inline&#34;&gt;\(y_{ij}\)&lt;/span&gt;, for a number, &lt;span class=&#34;math inline&#34;&gt;\(i = 1, ..., N\)&lt;/span&gt;, of ligand concentrations &lt;span class=&#34;math inline&#34;&gt;\([A_{ij}]\)&lt;/span&gt;. We also know that the assay response averages to the tissue response, &lt;span class=&#34;math inline&#34;&gt;\(\mu_{ij}\)&lt;/span&gt;, but that observations are noisy:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[y_{ij} \sim {\sf Normal}(\mu_{ij}, \sigma)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Note that the noise parameter, &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt;, is the same for all &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; compounds.&lt;/p&gt;
&lt;p&gt;The tissue response is a deterministic function of four kinetic parameters, as described by the Hill equation:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\mu_{ij} = top - \frac{bottom_j - top}{1 + 10^{(\log_{10}(IC_{50,j}) - \log_{10}([A_{ij}]))^{n_H}}}\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;priors&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Priors&lt;/h2&gt;
&lt;p&gt;For the minimum response parameter, &lt;span class=&#34;math inline&#34;&gt;\(top\)&lt;/span&gt;, we will specify a narrow prior, as we have no indication that it should be anything other than 1.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[top \sim {\sf Normal}(1, 0.01)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In a real scenario the Hill number, &lt;span class=&#34;math inline&#34;&gt;\(n_H\)&lt;/span&gt;, will probably be well know before high throughput screening experiments are done. For the purpose of demonstration, however, we will give it a relatively wide prior and hope to learn the true number from our data, in this case.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[n_H \sim {\sf LogNormal}(0, 0.5)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;For sigma &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt;, we put a prior that corresponds to a mean standard deviation that is 10% of the assay window. We also want very high noise to be very unlikely.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\sigma \sim {\sf Exp}(10)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We now have multiple &lt;span class=&#34;math inline&#34;&gt;\(bottom_i\)&lt;/span&gt; parameters to consider.&lt;/p&gt;
&lt;p&gt;We know that the most likely scenario is where our modification causes the ligand to lose efficacy yielding a minimum tissue response somewhere between 0 and 1. However, there is a small chance that our superior design yields a ligand that is more efficacious than the endogenous ligand and thus has a minimum response below 0. Our prior for the &lt;span class=&#34;math inline&#34;&gt;\(bottom\)&lt;/span&gt; parameter should thus be concentrated between 0 and 1 but with some probability below 0. Let’s try a normal prior.&lt;/p&gt;
&lt;p&gt;The question that remains is whether this argument is true for all &lt;span class=&#34;math inline&#34;&gt;\(bottom_i\)&lt;/span&gt;. We are going to assume that it is and use the same prior for all &lt;span class=&#34;math inline&#34;&gt;\(bottom_i\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[bottom_i \sim {\sf Normal}(0.25, 0.25)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The modified ligand is likely to lose potency, i.e. have a higher &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50,i})\)&lt;/span&gt;, compared to the endogenous ligand which has &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50,i}) = -7.2\)&lt;/span&gt;, but we might get lucky and see an increase. This is not much to go on, but it should still allow us to use a somewhat narrow prior. Again, we will use the same prior for all &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50,i})\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;We added a bit of an extra challenge, allowing for some compounds to have very high &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50,i})\)&lt;/span&gt;. For now, we are going to pretend that we do not have that knowledge and see what this prior will do for us. In a real world scenario, we never know the true distributions. The best priors arise by applying our scientific experience and logic.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\log_{10}(IC_{50}) \sim {\sf Normal}(-6, 1.5)\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;prior-predictive-simulation&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Prior Predictive Simulation&lt;/h1&gt;
&lt;p&gt;With the model and priors in place, we should control the sensibility of them with a prior predictive check. So let’s imagine that we perform the screening experiment, sampling the underlying parameters from our prior distributions, and have a look at the hypothetical observations that would arise.&lt;/p&gt;
&lt;p&gt;Let’s go ahead and define a function for sampling our priors and simulating a screening experiment.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;prior_parameters &amp;lt;- function(n_compounds = NULL,
                             bottom_mean = NULL,
                             bottom_sd = NULL,
                             top_mean = NULL,
                             top_sd = NULL,
                             log_IC50_mean = NULL,
                             log_IC50_sd = NULL,
                             nH_meanlog = NULL,
                             nH_sdlog = NULL,
                             sigma_rate = NULL) {
  tibble::tibble(
      compound = seq(1, n_compounds),
      bottom = rnorm(n_compounds, bottom_mean, bottom_sd),
      log_IC50 = rnorm(n_compounds, log_IC50_mean, log_IC50_sd),
      top = rnorm(1, top_mean, top_sd),
      nH = rlnorm(1, nH_meanlog, nH_sdlog),
      sigma = rexp(1, sigma_rate)
    )
}

screening_experiment &amp;lt;- function(parameters, log_conc) {
  parameters %&amp;gt;% 
    tidyr::expand_grid(log_conc = log_conc) %&amp;gt;%
    dplyr::mutate(
      response = assay_response(log_conc, bottom, top, log_IC50, nH, sigma)
    )
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can do our prior predictive check by performing a hypothetical experiment with our priors&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;priors &amp;lt;- list(
  bottom_mean &amp;lt;- 0.25,
  bottom_sd &amp;lt;- 0.25,
  top_mean &amp;lt;- 1,
  top_sd &amp;lt;- 0.01,
  log_IC50_mean &amp;lt;- -6,
  log_IC50_sd &amp;lt;- 1.5,
  nH_meanlog &amp;lt;- 0,
  nH_sdlog &amp;lt;- 0.5,
  sigma_rate &amp;lt;- 10
)

replicate(
  10,
  rlang::exec(
    prior_parameters,
    n_compounds = 5,
    !!!priors
  ),
  simplify = FALSE
) %&amp;gt;%
  dplyr::bind_rows(.id = &amp;quot;rep&amp;quot;) %&amp;gt;%
  dplyr::mutate(rep = paste0(rep, &amp;quot;-&amp;quot;, compound)) %&amp;gt;%
  screening_experiment(log_conc = seq(-10, -2, length.out = 100)) %&amp;gt;%
  ggplot(aes(x = log_conc, y = response, group = rep)) +
    geom_line(colour = colour$blue_dark, alpha = 0.5) +
    theme_minimal() +
    labs(
    x = &amp;quot;log ligand concentration&amp;quot;,
    y = &amp;quot;response&amp;quot;,
    title = &amp;quot;Prior Samples&amp;quot;
    )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/bespoke-biochem-two/index_files/figure-html/prior_predictive_check-1.png&#34; width=&#34;90%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Our prior understanding of the data generating process predicts a diverse set of curves. One of the things that often surprises me is the large number of seeming outliers, even with conservative estimates for noise. Given variance and enough samples, we are bound to see some weird behaviour.&lt;/p&gt;
&lt;p&gt;I think that these hypothetical samples seem like a fair representation of the samples I expect to get from the assay. If for some reason we thought that the hypothetical samples looked too extreme or did not represent the full range of possible observations, we would have to go back and adjust our priors.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;bayesian-model&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Bayesian Model&lt;/h1&gt;
&lt;p&gt;Now it is time for the fun part. First we implement the complete Bayesian model, consisting of our observational model and prior distributions, in Stan.&lt;/p&gt;
&lt;p&gt;The trick here is to define an index variable that keeps track of parameters for individual curves.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;writeLines(readLines(&amp;quot;hill_equation_screening.stan&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;data {
  int&amp;lt;lower=0&amp;gt; N;
  int&amp;lt;lower=0&amp;gt; M;
  int&amp;lt;lower=0&amp;gt; curve_ind[N];
  vector[N] log_conc;
  vector[N] y;
}

parameters {
  real top;
  vector&amp;lt;upper=top&amp;gt;[M] bottom;
  vector[M] log_IC50;
  real&amp;lt;lower=0&amp;gt; nH;
  real&amp;lt;lower=0&amp;gt; sigma;
  
}

model {
  vector[N] mu;
  bottom ~ normal(0.25, 0.25);
  top ~ normal(1, 0.01);
  log_IC50 ~ normal(-6, 1.5);
  nH ~ normal(1, 0.01);
  sigma ~ exponential(10);
  for ( i in 1:N ) {
    mu[i] = top + (bottom[curve_ind[i]] - top) 
                  / (1 + 10^((log_IC50[curve_ind[i]] - log_conc[i])*nH));
  }
  y ~ normal(mu, sigma);
}

generated quantities {
  vector[N] mu;
  vector[N] y_sampled;
  for ( i in 1:N ) {
    mu[i] = top + (bottom[curve_ind[i]] - top) 
                  / (1 + 10^((log_IC50[curve_ind[i]] - log_conc[i])*nH));
    y_sampled[i] = normal_rng(mu[i], sigma);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;conditioning&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Conditioning&lt;/h2&gt;
&lt;p&gt;Next we need some data to condition our model on. So we perform a simulated screening experiment using our true parameters. Recall that we have 100 compounds. In the screening experiment we will sample the tissue response for each compound at 6 different concentrations.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;assay_window &amp;lt;- seq(-8, -2, length.out = 6)

observations &amp;lt;- screening_experiment(
  parameters = true_parameters,
  log_conc = assay_window
)

data &amp;lt;- list(
  N = nrow(observations),
  M = max(observations$compound),
  curve_ind = observations$compound,
  log_conc = observations$log_conc,
  y = observations$response
)

post &amp;lt;- rstan::stan_model(&amp;quot;hill_equation_screening.stan&amp;quot;) %&amp;gt;%
  rstan::sampling(
    data = data,
    chains = 4,
    cores = 4,
    seed = 4444
  )

# Extract samples from the posterior distribution
posterior_samples &amp;lt;- rstan::extract(post) %&amp;gt;% tibble::as_tibble()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;examining-the-posterior&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Examining the Posterior&lt;/h1&gt;
&lt;p&gt;Before applying the model, we should do some quality assurance. Since we have simulated data, we can of course compare the posterior distributions to our known truth, and we will definitely do that, in a moment. In real problems, however, the truth is not known and we have to rely on other approaches.&lt;/p&gt;
&lt;p&gt;Here I have three approaches that rely only on the model and the data. None of the approaches will tell us whether the model is a good one, but they will often indicate any problems.&lt;/p&gt;
&lt;div id=&#34;quality-of-the-monte-carlo-simulation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Quality of the Monte Carlo Simulation&lt;/h2&gt;
&lt;p&gt;The first thing we can do is do a quality check of the Monte Carlo sampling. Stan usually complains when something seems wrong, but we can also check some specific diagnostics.&lt;/p&gt;
&lt;p&gt;I often get divergent transitions when I build multilevel models and they are a signal that there are areas of the model space that are difficult to traverse. Often they can be fixed by increasing the &lt;code&gt;adapt_delta&lt;/code&gt; parameter like we did in a previous study. When that does not work, it is a sign that maybe the model needs to be re-parametrised. For our model in this study, we should not have that problem, though.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rstan::check_divergences(post)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0 of 4000 iterations ended with a divergence.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When Stan complains about maximum tree depth it is because the Monte Carlo sampler was unable to fully explore some parts of the model space. It is really only an efficiency metric, but a common piece of advise when experiencing tree depth warnings is to use narrower priors. I also often find that I see this warning when I have forgotten to put an explicit prior on a parameter. In this case, we have put a lot of thought into our priors and they should be good.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rstan::check_treedepth(post)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0 of 4000 iterations saturated the maximum tree depth of 10.&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;convergence&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Convergence&lt;/h2&gt;
&lt;p&gt;We should also check check whether each of our parameters have properly converged. Stan provides two metrics for us to review. &lt;span class=&#34;math inline&#34;&gt;\(\hat{R}\)&lt;/span&gt; is a measure of convergence and when &lt;span class=&#34;math inline&#34;&gt;\(\hat{R} &amp;gt; 1.01\)&lt;/span&gt; it is an indication that the posterior samples aren’t quite representative of the true posterior distribution.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\_eff\)&lt;/span&gt; is an estimate of the number of true samples our chains represent. If the number of effective samples is low compared to the number of samples we chose to take after warm up, it indicates that it was difficult for the Monte Carlo sampler to figure out that parameter in the grand scheme of things. Sometimes it helps to increase &lt;code&gt;adapt_delta&lt;/code&gt; and do more warm-up samples, but I find that it is also often indicative of data that is very incompatible with the model and its priors. In this study, we ran four chains with 1000 samples after warm-up, so we would like to see at least several hundred effective samples.&lt;/p&gt;
&lt;p&gt;Let’s just have a look at the parameters that proved to be most difficult.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;post_summaries &amp;lt;- rstan::summary(
  post,
  pars = c(&amp;quot;bottom&amp;quot;, &amp;quot;log_IC50&amp;quot;),
  probs = NULL
)$summary

tibble::as_tibble(post_summaries) %&amp;gt;%
  dplyr::select(-c(mean, se_mean, sd)) %&amp;gt;%
  dplyr::mutate(parameter = rownames(post_summaries), .before = 1) %&amp;gt;%
  dplyr::mutate(dplyr::across(-parameter, round, digits = 3)) %&amp;gt;%
  dplyr::arrange(desc(Rhat)) %&amp;gt;%
  dplyr::slice_head(n = 10) %&amp;gt;%
  knitr::kable()&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;parameter&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;n_eff&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Rhat&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;log_IC50[83]&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1177.101&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.003&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;bottom[2]&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4258.387&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.002&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;log_IC50[2]&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4483.525&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.002&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;log_IC50[37]&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1349.972&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.002&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;log_IC50[71]&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2269.627&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.002&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;bottom[26]&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3953.336&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;bottom[32]&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6086.841&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;bottom[37]&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1252.062&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;bottom[44]&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4487.325&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;bottom[71]&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4270.506&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.001&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;It looks like our parameters have converged nicely.&lt;/p&gt;
&lt;p&gt;Note that some parameters have &lt;span class=&#34;math inline&#34;&gt;\(n\_eff\)&lt;/span&gt; that are quite a bit below the 4000 samples after warm-up. This is not necessarily a cause for concern, but in case it is very low and we want to use the distribution for predictive purposes, it might be a good idea to increase the number of samples after warm-up a bit.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;data-replication-check&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Data Replication Check&lt;/h2&gt;
&lt;p&gt;A great sanity check for a model is whether it is able to replicate the data. Our model is fully generative, meaning we can generate hypothetical samples. For a good model, when we generate a number of samples corresponding to the number of data points, the qualitative properties those samples should be similar to those of the original data. Parameters like mean and variance will be very similar, as those are basically the parameters we conditioned on the data, but more qualitative aspects like minimum data point, maximum, or general shape are not a given.&lt;/p&gt;
&lt;p&gt;In the Stan script, I included some generated quantities that are essentially sample observations, so we can compare. We will skip comparing maximum and minimum and just compare the overall shape.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot() +
  geom_histogram(
    data = observations,
    mapping = aes(x = response, y = ..density.., fill = &amp;quot;Observed responses&amp;quot;),
    bins = 30,
    alpha = 0.5
  ) +
  geom_histogram(
    data = tibble::tibble(y_sampled = as.vector(posterior_samples$y_sampled)),
    mapping = aes(x = y_sampled, y = ..density.., fill = &amp;quot;Posterior samples&amp;quot;),
    bins = 300,
    alpha = 0.5
  ) +
  theme_minimal() +
  scale_fill_manual(values = list(
    &amp;quot;Observed responses&amp;quot; = colour$azure,
    &amp;quot;Posterior samples&amp;quot; = colour$blue_dark
  )) +
  labs(
    fill = &amp;quot;&amp;quot;,
    y = &amp;quot;Density&amp;quot;,
    x = &amp;quot;Response&amp;quot;,
    title = &amp;quot;Shape Check&amp;quot;
  )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/bespoke-biochem-two/index_files/figure-html/shape_check-1.png&#34; width=&#34;90%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;It really looks like out model replicates the data quite nicely. Usually the concerns are whether the tails match; if the data has minimum points that are outside what the model yields or if the samples span a much wider range than the data, it might be cause to rethink the model.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;results&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Results&lt;/h1&gt;
&lt;p&gt;Our model and the posterior samples seem to be of decent quality, so let’s put them to use.&lt;/p&gt;
&lt;div id=&#34;posterior-marginal-distributions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Posterior Marginal Distributions&lt;/h2&gt;
&lt;p&gt;So our model has 203 parameters, 2 for each of the 100 compounds and 3 parameters that are shared between all of them. Let’s see what we have learned about the three shared parameters.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# True parameters of the simulation.
truth &amp;lt;- true_parameters %&amp;gt;%
  dplyr::slice_head(n = 1) %&amp;gt;%
  tidyr::pivot_longer(
    dplyr::everything(),
    names_to = &amp;quot;parameter&amp;quot;,
    values_to = &amp;quot;truth&amp;quot;
  )

# A number of draws from our priors to match the number of draws we have from
#  the posterior
prior_samples &amp;lt;- replicate(
  nrow(posterior_samples),
  rlang::exec(
    prior_parameters,
    n_compounds = 1,
    !!!priors
  ),
  simplify = FALSE
) %&amp;gt;% 
  dplyr::bind_rows() %&amp;gt;%
  dplyr::select(top, nH, sigma) %&amp;gt;% 
  tidyr::pivot_longer(
    dplyr::everything(),
    names_to = &amp;quot;parameter&amp;quot;,
    values_to = &amp;quot;sample&amp;quot;
  )

# Plot each of the marginal distributions, comparing prior, posterior, and true
#  simulation parameters
posterior_samples %&amp;gt;%
  dplyr::select(top, nH, sigma) %&amp;gt;%
  tidyr::pivot_longer(
    dplyr::everything(),
    names_to = &amp;quot;parameter&amp;quot;,
    values_to = &amp;quot;sample&amp;quot;
  ) %&amp;gt;%
  dplyr::left_join(truth, by = &amp;quot;parameter&amp;quot;) %&amp;gt;%
  ggplot() +
  geom_histogram(
    data = prior_samples,
    mapping = aes(x = sample, fill = &amp;quot;Prior&amp;quot;),
    bins = 50,
    alpha = 0.5
  ) +
  geom_histogram(aes(x = sample, fill = &amp;quot;Posterior&amp;quot;), bins = 50, alpha = 0.5) +
  geom_vline(aes(xintercept = truth, colour = &amp;quot;truth&amp;quot;), alpha = 0.5) +
  facet_wrap(~ parameter, scales = &amp;quot;free&amp;quot;) +
  theme_minimal() +
  scale_colour_manual(values = c(&amp;quot;truth&amp;quot; = colour$orange_light)) +
  scale_fill_manual(values = c(
    &amp;quot;Prior&amp;quot; = colour$azure,
    &amp;quot;Posterior&amp;quot; = colour$blue_dark
  )) +
  labs(
    y = &amp;quot;Posterior sample count&amp;quot;,
    x = &amp;quot;&amp;quot;,
    colour = &amp;quot;&amp;quot;,
    fill = &amp;quot;&amp;quot;,
    title = &amp;quot;Marginal Posterior and Prior Distributions&amp;quot;
  )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/bespoke-biochem-two/index_files/figure-html/posterior_marginals_shared-1.png&#34; width=&#34;90%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;And some summary statistics&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;post_summaries &amp;lt;- rstan::summary(
  post,
  pars = c(&amp;quot;top&amp;quot;, &amp;quot;nH&amp;quot;, &amp;quot;sigma&amp;quot;),
  probs = c(0.055, 0.5, 0.945)
)$summary

tibble::as_tibble(post_summaries) %&amp;gt;%
  dplyr::select(-c(mean, se_mean, sd)) %&amp;gt;%
  dplyr::mutate(parameter = rownames(post_summaries), .before = 1) %&amp;gt;%
  dplyr::mutate(dplyr::across(-parameter, round, digits = 2)) %&amp;gt;%
  knitr::kable()&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;parameter&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5.5%&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;50%&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;94.5%&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;n_eff&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Rhat&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;top&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.02&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.03&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.04&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4667.23&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;nH&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.99&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.02&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9232.87&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;sigma&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.15&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.15&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.16&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2994.32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;When we fitted the curve for each individual compound, we ended up with posteriors that were very similar to our priors, indicating that the data was insufficient to provide additional information. In this case, however, we share information about the curve shape, sample noise, and the minimum response among all compounds. The pooling of all that information causes us to get very exact estimates for the curve shape and the sample noise. The estimates are even essentially equal to the truth. For the minimum response, our prior is still very informative compared to the data, so the posterior distribution has barely changed.&lt;/p&gt;
&lt;p&gt;These results are quite profound. Even with a relatively wide prior on &lt;span class=&#34;math inline&#34;&gt;\(n_H\)&lt;/span&gt;, corresponding to little knowledge about the kinetics of the response, we were able to estimate those exact kinetics, despite the data being intended for a different purpose. In real problems, we would often be much more sure about that parameter. Similarly, we have a very exact estimate of the experiment noise. If we regularly run such screening experiments this would be a great metric to track over time.&lt;/p&gt;
&lt;p&gt;We cannot look at parameters and curves for each of the compounds, so lets just pick a couple, including one that is difficult to fit. As with the shared parameters, we compare the posterior samples to the prior distribution and our known truth.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;example_compounds &amp;lt;- c(1:5, 93)

# True parameters of the simulation.
truth &amp;lt;- true_parameters %&amp;gt;%
  dplyr::filter(compound %in% example_compounds) %&amp;gt;%
  tidyr::pivot_longer(
    -compound,
    names_to = &amp;quot;parameter&amp;quot;,
    values_to = &amp;quot;truth&amp;quot;
  )

# A number of draws from our priors to match the number of draws we have from
#  the posterior
prior_samples &amp;lt;- replicate(
  nrow(posterior_samples),
  rlang::exec(
    prior_parameters,
    n_compounds = 1,
    !!!priors
  ),
  simplify = FALSE
) %&amp;gt;% 
  dplyr::bind_rows() %&amp;gt;%
  dplyr::select(bottom, log_IC50) %&amp;gt;% 
  tidyr::pivot_longer(
    dplyr::everything(),
    names_to = &amp;quot;parameter&amp;quot;,
    values_to = &amp;quot;sample&amp;quot;
  ) %&amp;gt;%
  tidyr::expand_grid(compound = example_compounds)

# Plot each of the marginal distributions, comparing prior, posterior, and true
#  simulation parameters
lapply(example_compounds, function(i) {
  tibble::tibble(
    bottom = posterior_samples$bottom[,i],
    log_IC50 = posterior_samples$log_IC50[,i],
    compound = i
  )
}) %&amp;gt;% 
  dplyr::bind_rows() %&amp;gt;%
  tidyr::pivot_longer(
    -compound,
    names_to = &amp;quot;parameter&amp;quot;,
    values_to = &amp;quot;sample&amp;quot;
  ) %&amp;gt;%
  dplyr::left_join(truth, by = c(&amp;quot;parameter&amp;quot;, &amp;quot;compound&amp;quot;)) %&amp;gt;%
  ggplot() +
  geom_histogram(
    data = prior_samples,
    mapping = aes(x = sample, fill = &amp;quot;Prior&amp;quot;),
    bins = 50,
    alpha = 0.5
  ) +
  geom_histogram(aes(x = sample, fill = &amp;quot;Posterior&amp;quot;), bins = 50, alpha = 0.5) +
  geom_vline(aes(xintercept = truth, colour = &amp;quot;truth&amp;quot;), alpha = 0.5) +
  facet_grid(rows = vars(compound), cols = vars(parameter), scales = &amp;quot;free&amp;quot;) +
  theme_minimal() +
  theme(strip.text.y = element_text(angle = 0)) +
  scale_colour_manual(values = c(&amp;quot;truth&amp;quot; = colour$orange_light)) +
  scale_fill_manual(values = c(
    &amp;quot;Prior&amp;quot; = colour$azure,
    &amp;quot;Posterior&amp;quot; = colour$blue_dark
  )) +
  labs(
    y = &amp;quot;Posterior sample count&amp;quot;,
    x = &amp;quot;&amp;quot;,
    colour = &amp;quot;&amp;quot;,
    fill = &amp;quot;&amp;quot;,
    title = &amp;quot;Marginal Posterior and Prior Distributions&amp;quot;
  )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/bespoke-biochem-two/index_files/figure-html/posterior_marginals_compounds-1.png&#34; width=&#34;90%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;And some summary statistics&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;post_summaries &amp;lt;- rstan::summary(
  post,
  pars = c(&amp;quot;bottom&amp;quot;, &amp;quot;log_IC50&amp;quot;),
  probs = c(0.055, 0.5, 0.945)
)$summary

tibble::as_tibble(post_summaries) %&amp;gt;%
  dplyr::select(-c(mean, se_mean, sd)) %&amp;gt;%
  dplyr::mutate(parameter = rownames(post_summaries), .before = 1) %&amp;gt;%
  dplyr::mutate(dplyr::across(-parameter, signif, digits = 4)) %&amp;gt;%
  dplyr::filter(stringr::str_detect(
    parameter,
    paste0(&amp;quot;(\\[&amp;quot;, example_compounds, &amp;quot;\\])&amp;quot;, collapse = &amp;quot;|&amp;quot;)
  )) %&amp;gt;%
  knitr::kable()&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;parameter&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5.5%&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;50%&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;94.5%&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;n_eff&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Rhat&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;bottom[1]&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.26640&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.02345&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.2899&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6103.0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;bottom[2]&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.05292&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.30550&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.5976&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4258.0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0020&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;bottom[3]&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.25210&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.42120&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.5831&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5681.0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9995&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;bottom[4]&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.04298&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.18550&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.3221&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6510.0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9996&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;bottom[5]&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.14800&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.07444&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.2785&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5360.0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;bottom[93]&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.01054&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.22520&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.4813&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1621.0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9996&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;log_IC50[1]&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-3.38700&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-2.84400&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-2.3980&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4842.0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;log_IC50[2]&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-3.26300&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-2.54000&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-1.9200&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4484.0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0020&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;log_IC50[3]&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-5.83300&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-4.93800&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-4.1330&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6467.0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9993&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;log_IC50[4]&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-6.41500&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-5.83600&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-5.2860&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7889.0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.9995&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;log_IC50[5]&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-4.60200&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-3.93300&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-3.3400&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5696.0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;log_IC50[93]&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-6.41600&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-4.05500&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-3.4590&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;801.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.0010&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;At first glance, these results may seem unimpressive. Even though the posterior has concentrated compared to our prior, it is still fairly wide. Even the compounds with the narrowest estimate of potency has a 89% interval for &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50})\)&lt;/span&gt; spanning more than a unit, corresponding to more than an order of magnitude difference in concentration. That is quite a bit.&lt;/p&gt;
&lt;p&gt;Seen from another perspective though, we only had six data points to estimate each of those two parameters. If we were extremely confident in the resulting estimates that would be very suspicious. The means of the marginal posterior distributions are close to the truth, so we have good estimates for any downstream analysis, but the relatively wide distributions are there to remind us that our estimate is uncertain.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;posterior-predictive&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Posterior Predictive&lt;/h2&gt;
&lt;p&gt;One way to understand how much, or how little, our model has learned from the data is to visualise the posterior predictions along with the original data. Here is a curve where things went rather well&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;example_curves &amp;lt;- tibble::tibble(curve = c(3, 93))
example_curves$post_pred &amp;lt;- purrr::map(example_curves$curve, function(i) {
  posterior_samples %&amp;gt;%
  dplyr::mutate(
    log_IC50 = log_IC50[, i],
    bottom = bottom[, i]
  ) %&amp;gt;%
  tidyr::expand_grid(log_conc = seq(-2, -9, length.out = 50)) %&amp;gt;% 
  dplyr::mutate(tissue_response = purrr::pmap_dbl(
    list(log_conc, bottom, top, log_IC50, nH),
    hill_function
  )) %&amp;gt;%
  dplyr::group_by(log_conc) %&amp;gt;%
  dplyr::summarise(
    response_mean = mean(tissue_response),
    response_upper = quantile(tissue_response, probs = 0.945),
    response_lower = quantile(tissue_response, probs = 0.055)
  ) %&amp;gt;%
  ggplot() +
  geom_ribbon(
    aes(
      x = log_conc,
      ymin = response_lower,
      ymax = response_upper,
      fill = &amp;quot;89% interval&amp;quot;
    ),
    alpha = 0.5
  ) +
  geom_line(aes(x = log_conc, y = response_mean, colour = &amp;quot;Posterior mean&amp;quot;)) +
  geom_point(
    data = dplyr::filter(observations, compound == i),
    aes(x = log_conc, y = response, colour = &amp;quot;Observations&amp;quot;)
  ) +
  geom_function(
    fun = hill_function,
    args = true_parameters[i, -c(1,6)],
    mapping = aes(colour = &amp;quot;True tissue response&amp;quot;)
  ) +
  labs(
    y = &amp;quot;Tissue response&amp;quot;,
    x = &amp;quot;Log ligand concentration [M]&amp;quot;,
    colour = &amp;quot;&amp;quot;,
    fill = &amp;quot;&amp;quot;,
    title = paste(&amp;quot;Posterior Predictive for Compound&amp;quot;, i)
  ) +
  scale_fill_manual(values = c(&amp;quot;89% interval&amp;quot; = colour$azure)) +
  theme_minimal()
})
example_curves$post_pred_coloured &amp;lt;- purrr::map(
  example_curves$post_pred,
  function(p) {
    p + scale_colour_manual(values = c(
      &amp;quot;Posterior mean&amp;quot; = colour$blue_dark,
      &amp;quot;Observations&amp;quot; = colour$orange_light,
      &amp;quot;True tissue response&amp;quot; = colour$orange_dark
    ))
  }
)
example_curves$post_pred_coloured[[1]]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/bespoke-biochem-two/index_files/figure-html/posterior_predictive-1.png&#34; width=&#34;90%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Our model is very open about its uncertainty. While the posterior mean is a great compromise between the data points, the model also knows that the assay is noisy, and it has used the pooled estimate of that noise across all curves to give us this nice interval for any point prediction. Not also how the model has confidently ruled out one of the points as an outlier. I think this is a lot of information gained from just a few points of data.&lt;/p&gt;
&lt;p&gt;Now let’s have a look at a more difficult case&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;example_curves$post_pred_coloured[[2]]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/bespoke-biochem-two/index_files/figure-html/posterior_predictive_2-1.png&#34; width=&#34;90%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This one is difficult because we did not get any good points on the curved part of the tissue response. This makes the estimate for &lt;span class=&#34;math inline&#34;&gt;\(\log_{10}(IC_{50})\)&lt;/span&gt; very uncertain, resulting in the bulge in the middle. Despite all this, the 89% interval nicely contains the true tissue response.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;model-comparison&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Model Comparison&lt;/h2&gt;
&lt;p&gt;Before we wrap up, I want to highlight why I like this approach to modelling my screening assay data in this way by comparing it to a classic model fitting method.&lt;/p&gt;
&lt;p&gt;For the comparison, we will use non-linear least squares to directly fit the Hill equation to the data points for a compound. We cannot put flexible priors on the parameters, but we can set constraints that limit the parameters to a range comparable to that of the priors in our Bayesian model.&lt;/p&gt;
&lt;p&gt;Again let’s start by looking at the case where things go well.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;example_curves$model_comp &amp;lt;- purrr::map2(
  example_curves$curve,
  example_curves$post_pred,
  function(curve, p) {
    mod &amp;lt;- nls(
      response ~ top + (bottom - top)/(1 + 10^((log_IC50 - log_conc)*nH)),
      data = dplyr::filter(observations, compound == curve),
      algorithm = &amp;quot;port&amp;quot;,
      start = list(bottom = 0.25, top = 1, log_IC50 = -6, nH = 1),
      lower = list(bottom = -0.3, top = 0.98, log_IC50 = -9, nH = 0),
      upper = list(bottom = 1.0, top = 1.02, log_IC50 = -3, nH = 2)
    )
    
    p +
      geom_function(
        fun = hill_function,
        args = mod$m$getPars(),
        mapping = aes(colour = &amp;quot;NLS fit&amp;quot;)
      ) +
      scale_colour_manual(values = c(
        &amp;quot;Posterior mean&amp;quot; = colour$blue_dark,
        &amp;quot;Observations&amp;quot; = colour$orange_light,
        &amp;quot;True tissue response&amp;quot; = colour$orange_dark,
        &amp;quot;NLS fit&amp;quot; = &amp;quot;black&amp;quot;
      ))
  }
)

example_curves$model_comp[[1]]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/bespoke-biochem-two/index_files/figure-html/model_comp-1.png&#34; width=&#34;90%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The least squares model is almost identical to our posterior mean estimate and both are close to the truth. This is not altogether surprising, as we had great data points to fit the model curve on. However, only the Bayesian model comes with an estimate of the uncertainty. With the least squares model, we could easily grow overconfident in the fitted parameters.&lt;/p&gt;
&lt;p&gt;Let’s have a look at the more difficult case.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;example_curves$model_comp[[2]]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/bespoke-biochem-two/index_files/figure-html/model_comp_2-1.png&#34; width=&#34;90%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;In this case, the least squares fit was not really able to find a good foothold in the data, yet it confidently reports the fitted parameters. Granted, our Bayesian model had its troubles too, but at least it reports the extreme uncertainty.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;In this study, we built and explored a Bayesian model for understanding large compound screening assays. We showed that we can use our prior knowledge to build a bespoke model and that such a model provides us with more useful information than a conventional least squares model. We experienced that it takes a bit more work to ensure the quality of a Bayesian model, but we tried out a few ways to do so.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;next-steps&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Next Steps&lt;/h1&gt;
&lt;p&gt;In the preceding study, we assumed that the compounds were random perturbations on a known endogenous ligand. We also assumed that the observations arose under similar circumstances such that they shared a common noise parameter. These assumptions may hold in some cases, but often we know more about our data than that.&lt;/p&gt;
&lt;p&gt;Maybe the permutations could be described with categories or other labels.&lt;/p&gt;
&lt;p&gt;Maybe we performed our screening assay in batches across multiple days, resulting in a possible batch effect on observation data quality.&lt;/p&gt;
&lt;p&gt;Either of these cases add another layer of complexity, but batch effects and labels are both things we can handle with a bespoke Bayesian model. These are the subjects of a future study. Stay tuned!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;license&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;License&lt;/h1&gt;
&lt;p&gt;The content of this project itself is licensed under the &lt;a href=&#34;https://creativecommons.org/licenses/by-sa/4.0/&#34;&gt;Creative Commons Attribution-ShareAlike 4.0 International license&lt;/a&gt;, and the underlying code is licensed under the &lt;a href=&#34;https://github.com/AnHosu/bespoke-bayesian-biochem/blob/main/LICENSE&#34;&gt;GNU General Public License v3.0 license&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
